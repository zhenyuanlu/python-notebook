{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Notebook from Zero to Advanced","text":"<p>Author: Zhenyuan Lu</p> <p>Version: 1.0.0</p> <p>Created: 12/05/2022, last modified on 07/29/2023</p> <p>PDF version: Python Notebook from Zero to Advanced</p> <p>Welcome to the Python Notebook from Zero to Advanced, an simplistic place on the internet to learn Python (besides the best place official Python documentation, of course  )</p>"},{"location":"#about-this-book","title":"About This Book","text":"<p>This book is designed for those with little or no Python programming experience, and it is filled with concise, easy-to-understand examples that will help you learn quickly and effectively.</p> <p>Throughout this comprehensive guide, we'll cover a wide range of topics, including data types, control structures, functions, and more. </p>"},{"location":"00_disclaimer/","title":"Disclaimer","text":"<p>I am pretty sure there are some typing errors, spelling mistakes, and other inaccuracies. If you find any such issues, please do not hesitate to contact me via lu [dot] zhenyua [at] northeastern [dot] edu.</p> <p>This tutorial is aimed to those who have zero or less Python programming experience with concise and simple examples throughout the entire tutorial. The content has been inspired by official Python documentation, Corey Schafer's tutorial. If you believe any content has been used inappropriately, please let me know, and I will address the issue.</p> <p>This work is licensed under the MIT License.</p>"},{"location":"01_get_started/","title":"Get Started","text":"<p>Welcome! Python is a versatile and powerful programming language, widely used for web development, data analysis, artificial intelligence, and more. This tutorial will guide you through the installation of Python and setting up a Python development environment in PyCharm, a popular integrated development environment (IDE) for Python.</p> <p>To get started with Python, you'll first need to install it on your computer. Follow the instructions below for your operating system:</p>"},{"location":"01_get_started/#11-installation-with-anaconda","title":"1.1. Installation with Anaconda","text":"<p>Anaconda is a popular distribution of Python and R programming languages, which simplifies package management and deployment. It comes with many pre-installed packages and tools for data science and machine learning.</p> <p>For Windows:</p> <p>Visit the Anaconda website at https://www.anaconda.com/products/distribution and download the installer for your operating system. Run the installer and follow the installation instructions. After the installation is complete, you can verify the installation by opening a terminal (or Anaconda Prompt on Windows) and typing conda --version. You should see the installed Anaconda version displayed. To check the Python version, type <code>python --version</code>.</p> <p>For macOS:</p> <p>Visit the Anaconda website at https://www.anaconda.com/products/distribution and download the installer for macOS. Open the downloaded package (.pkg file) and follow the installation instructions. After the installation is complete, you can verify the installation by opening Terminal and typing conda --version. You should see the installed Anaconda version displayed. To check the Python version, type <code>python --version</code>.</p>"},{"location":"01_get_started/#12-standard-installation","title":"1.2. Standard Installation","text":"<p>For Windows:</p> <p>Visit the official Python website at https://www.python.org/downloads/ and download the latest version of Python. Run the installer. Be sure to check the box \"Add Python to PATH\" before clicking \"Install Now.\" This will make it easier to run Python from the command prompt. After the installation is complete, you can verify the installation by opening a command prompt and typing <code>python --version</code>. You should see the installed Python version displayed.</p> <p>For macOS:</p> <p>Visit the official Python website at https://www.python.org/downloads/ and download the latest version of Python. Open the downloaded package and follow the installation instructions. After the installation is complete, you can verify the installation by opening Terminal and typing <code>python --version</code>. You should see the installed Python version displayed.</p>"},{"location":"01_get_started/#12-setting-up-a-python-development-environment-in-pycharm","title":"1.2. Setting up a Python Development Environment in PyCharm","text":"<p>Now that Python is installed, let's set up a development environment in PyCharm.</p> <ol> <li> <p>Download and install PyCharm from https://www.jetbrains.com/pycharm/download/. There are two editions available: Community Edition (free) and Professional Edition (paid). For this tutorial, the Community Edition is sufficient.</p> </li> <li> <p>Open PyCharm and create a new project by clicking \"Create New Project\" on the welcome screen.</p> </li> <li> <p>Choose a location for your project and make sure the \"Python Interpreter\" field is set to the Python version you installed earlier. If not, click the gear icon next to the field and select \"Add Interpreter.\" Choose \"System Interpreter\" and select the Python executable from the list. Click \"Create\" to create your new Python project.</p> </li> <li> <p>You're now ready to start writing Python code! In the next chapter, we'll dive into Python basics, including syntax, variables, and data types.</p> </li> </ol>"},{"location":"02_data_types/","title":"2. Data Types","text":""},{"location":"02_data_types/#21-numbers","title":"2.1. Numbers","text":"<p>In this section, we will cover the different number types in Python, such as integers and floating-point numbers, and how to work with them.</p>"},{"location":"02_data_types/#211-integers-and-floats","title":"2.1.1. Integers and Floats","text":"<p>Python has two primary numeric types: integers (int) and floating-point numbers (float). </p> <p>Assign an integer <code>5</code> to a variable named <code>num</code>. The <code>print()</code> function is then used to output the value of <code>num</code> to the console.  Input<pre><code># Integers\nnum = 5\nprint(num)\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>Assign a floating-point number <code>5.2</code> to a variable named <code>num</code>. The <code>print()</code> function is then used to output the value of <code>num</code> to the console. Input<pre><code># Floats\nnum = 5.2\nprint(num)\n</code></pre> Output<pre><code>5.2\n</code></pre></p>"},{"location":"02_data_types/#212-type-and-__class__","title":"2.1.2. <code>type()</code> and <code>__class__</code>","text":"<p>Info</p> <p><code>type()</code> is a built-in function that returns the type of an object. It is the same as calling the object's <code>__class__</code> attribute, e.g. <code>object.__class__</code>, but which is less commonly used.</p> <p>Use <code>type()</code> to check the type of a variable. Input<pre><code>num = 5\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'int'&gt;\n</code></pre></p> <p>The num variable is a floating-point number, so the <code>type()</code> function returns <code>&lt;class 'float'&gt;</code>.</p> <p>Input<pre><code># Floats\nnum = 5.2\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'float'&gt;\n</code></pre></p> <p>Floats with scientific notation. Input<pre><code>num = 5.2e3\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'float'&gt;\n</code></pre></p> <p>Use <code>__class__</code> to check the type of a variable.  Input<pre><code>print(num.__class__)\n</code></pre> Output<pre><code>&lt;class 'int'&gt;\n</code></pre></p>"},{"location":"02_data_types/#213-math-functions","title":"2.1.3. Math Functions","text":"<p>Python supports various mathematical operations that can be performed on numbers, such as addition, subtraction, multiplication, division, and more. Here's a list of common mathematical operations and their corresponding symbols:</p> <ul> <li>Addition: <code>+</code></li> <li>Subtraction: <code>-</code></li> <li>Multiplication: <code>*</code></li> <li>Division: <code>/</code></li> <li>Floor Division: <code>//</code></li> <li>Exponentiation: <code>**</code></li> <li>Modulus: <code>%</code></li> </ul> <p>Let's see some examples of using these mathematical operations:</p> AdditionSubtractionMultiplicationDivisionFloor DivisionExponentiationModulus <p>Input<pre><code>num = 5\nprint(num + 2)\n</code></pre> Output<pre><code>7\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num - 2)\n</code></pre> Output<pre><code>3\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num * 2)\n</code></pre> Output<pre><code>10\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num / 2)\n</code></pre> Output<pre><code>2.5\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num // 2)\n</code></pre> Output<pre><code>2\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num ** 2)\n</code></pre> Output<pre><code>25\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num % 2)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>These operations can be used in combination, following the standard order of operations (PEMDAS), to perform more complex calculations. Parentheses can be used to specify the order of operations explicitly.</p> <p><code>abs()</code> and <code>round()</code></p> <p><code>abs()</code> and <code>round()</code> are two built-in functions that can be used to perform mathematical operations on numbers. </p> <p>The <code>abs()</code> function returns the absolute value of a number.</p> <p>Input<pre><code># abs() function\nprint(abs(-5))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>The <code>round()</code> function rounds a number to a specified number of decimal places.</p> <p>Input<pre><code># round() function\nprint(round(5.75))\n</code></pre> Output<pre><code>6\n</code></pre></p> <p><code>round()</code> with 2nd argument to specify the number of decimal places. Here we round <code>5.75</code> to 1 decimal place.</p> <p>Input<pre><code># round() with 2nd argument\nprint(round(5.75, 1))\n</code></pre> Output<pre><code>5.8\n</code></pre></p>"},{"location":"02_data_types/#214-increment-and-decrement","title":"2.1.4. Increment and Decrement","text":"<p>In Python, you can increment or decrement the value of a variable using the <code>+=</code> and <code>-=</code> operators, respectively. These operators are shorthand for adding or subtracting a value to the variable and then assigning the result back to the variable.</p> <p>We use <code>num = num + 1</code> to increment the value of <code>num</code> by 1.  Input<pre><code># Increment\nnum = 5\nnum = num + 1\nprint(num)\n</code></pre> Output<pre><code>6\n</code></pre></p> <p>Increment using shorthand <code>+=</code> operator. The <code>+=</code> operator is equivalent to <code>num = num + 1</code>.</p> <p>Input<pre><code># Increment using shorthand +=\nnum = 5\nnum += 1\nprint(num)\n</code></pre> Output<pre><code>6\n</code></pre></p> <p>The <code>num = num - 1</code> is used to decrement the value of <code>num</code> by 1. Input<pre><code># Decrement\nnum = 5\nnum = num - 1\nprint(num)\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>Decrement using shorthand <code>-=</code> operator. The <code>-=</code> operator is equivalent to <code>num = num - 1</code>. Input<pre><code># Decrement using shorthand -=\nnum = 5\nnum -= 1\nprint(num)\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>Using the <code>+=</code> and <code>-=</code> operators can make your code shorter and more readable, especially when performing multiple increment or decrement operations on the same variable.</p>"},{"location":"02_data_types/#215-comparison-operators","title":"2.1.5. Comparison Operators","text":"<ul> <li>Equal: <code>==</code></li> <li>Not Equal: <code>!=</code></li> <li>Greater Than: <code>&gt;</code></li> <li>Less Than: <code>&lt;</code></li> <li>Greater or Equal: <code>&gt;=</code></li> <li>Less or Equal: <code>&lt;=</code></li> </ul> Setting<pre><code>num_1 = 5\nnum_2 = 2\n</code></pre> Equal: ==Not Equal: !=Greater Than: &gt;Less Than: &lt;Greater or Equal: &gt;=Less or Equal: &lt;= <p>Input<pre><code>print(num_1 == num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p> <p>Input<pre><code>print(num_1 != num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &gt; num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &lt; num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p> <p>Input<pre><code>print(num_1 &gt;= num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &lt;= num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p>"},{"location":"02_data_types/#216-casting","title":"2.1.6. Casting","text":"<p>Casting is the process of converting a value from one data type to another. In Python, casting is achieved using built-in functions like <code>int()</code>, <code>float()</code>, and <code>complex()</code>.</p> <p>For example, when working with numbers, you might need to convert a string to an integer or a float. This is useful when you want to perform mathematical operations on string representations of numbers.</p> <p><code>int()</code>: Convert a value to an integer <code>float()</code>: Convert a value to a float <code>complex()</code>: Convert a value to a complex number</p> <p>Check the type of variable <code>num_1</code>. </p> <p>Input<pre><code>num_1 = '5'\nprint(type(num_1))\n</code></pre> Output<pre><code>&lt;class 'str'&gt;\n</code></pre></p> <p>If we have two numbers as strings, when we <code>+</code> them, they are concatenated instead of added.</p> <p>Input<pre><code>num_1 = '5'\nnum_2 = '2'\nprint(num_1 + num_2)\n</code></pre> Output<pre><code>52\n</code></pre></p> <p>If we want to add them, we need to convert them to integers first.</p> <p>Input<pre><code># Convert string to int\nnum_1 = int(num_1)\nnum_2 = int(num_2)\nprint(num_1 + num_2)\n</code></pre> Output<pre><code>7\n</code></pre></p> <p>If we convert a floating number to an integer, the decimal part will be removed.</p> <p>Input<pre><code>num = 5.2\nprint(int(num))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>If we convert an integer to a float, the result will be a float with <code>.0</code> at the end.</p> <p>Input<pre><code># float()\nnum = 5\nprint(float(num))\n</code></pre> Output<pre><code>5.0\n</code></pre></p> <p>If we convert an integer to a complex number, the result will be a complex number with <code>j</code> at the end.</p> <p>Input<pre><code># complex()\nnum = 5\nprint(complex(num))\n</code></pre> Output<pre><code>(5+0j)\n</code></pre></p> <p><code>zfill()</code> method adds zeros (0) at the beginning of the string, until it reaches the specified length.</p> <p>Input<pre><code># zfill method\nnum = 5\nprint(str(num).zfill(3))\n</code></pre> Output<pre><code>005\n</code></pre></p>"},{"location":"02_data_types/#22-strings","title":"2.2. Strings","text":"<p>Strings are one of the most important and commonly used data types in Python. A string is simply a sequence of characters, such as letters, numbers, and symbols. In Python, strings are created using either single quotes <code>'&lt;str&gt;'</code> or double quotes <code>\"&lt;str&gt;\"</code>. This tutorial will cover the basics of string manipulation in Python, including string indexing, slicing, concatenation, formatting, and various string methods.</p> <p>A string variable named sentence is defined and assigned the value <code>\"Hello World\"</code>. The <code>print()</code> function is then used to output the value of sentence to the console. This code demonstrates how to create and output a basic string in Python. </p> <p>Input<pre><code>sentence = 'Hello World'\nprint(sentence)\n</code></pre> Output<pre><code>Hello World\n</code></pre></p>"},{"location":"02_data_types/#221-string-basics","title":"2.2.1. String Basics","text":"<p>Quotes</p> <p>Single quotes are faster, more readable, and more commonly used than double quotes in Python. However, if a string itself contains a single quote, then it must be escaped using a backslash \\ so that Python can properly interpret the string.</p> <p>In the example code, a new string variable named sentence is defined using single quotes and contains the word <code>\"Tub's World\"</code>. To escape the single quote in the middle of the string, a backslash is used before it. The <code>print()</code> function is then used to output the value of sentence to the console. </p> <p>Input<pre><code># Single quote\n# Use backslash to escape single quote\nsentence = 'Tub\\'s World'\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>The following is the same example as above, but using double quotes instead of single quotes. </p> <p>Input<pre><code># Use double quote\nsentence = \"Tub's World\"\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>Triple quotes are used to create multi-line strings. In the example code, a new string variable named sentence is defined using triple quotes and contains the string <code>\"Tub's World\"</code> and <code>\"is a good place to live in\"</code>. The <code>print()</code> function is then used to output the value of sentence to the console. </p> <p>Input<pre><code># Three double quotes for multi-line string\nsentence = \"\"\"Tub's World\nis a good place to live in\"\"\"\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\nis a good place to live in\n</code></pre></p> <p>Length of a String</p> <p>The following code demonstrates how to use the <code>len()</code> function to get the length of a string.</p> <p>Input<pre><code># Use len() to get the length of a string\nsentence = \"Tub's World\"\nprint(len(sentence))\n</code></pre> Output<pre><code>12\n</code></pre></p> <p>Upper and Lower Case</p> <p>The <code>lower()</code> method converts all the characters in a string to lowercase. This is useful for case-insensitive comparisons or normalization of text data.</p> <p>Input<pre><code># Lowercase (all letters)\nsentence = \"Tub's World\"\nprint(sentence.lower())\n</code></pre> Output<pre><code>tub's world\n</code></pre></p> <p>The <code>upper()</code> method converts all the characters in a string to uppercase.</p> <p>Input<pre><code># Uppercase (all letters)\nsentence = \"Tub's World\"\nprint(sentence.upper())\n</code></pre> Output<pre><code>TUB'S WORLD\n</code></pre></p> <p>Input<pre><code># Capitalize\nsentence = \"Tub's World\"\nprint(sentence.capitalize())\n</code></pre> Output<pre><code>Tub's world\n</code></pre></p> <p>The <code>capitalize()</code> method capitalizes the first character of a string and makes the rest of the characters lowercase.</p>"},{"location":"02_data_types/#222-string-indexing","title":"2.2.2. String Indexing","text":"<p>Indexing allows us to access individual characters within a string using their position, also known as the index. It is essential to understand that in Python, indexing starts from 0, meaning the first character in the string has an index of 0, the second character has an index of 1, and so on.</p> <p>Here, we define a string sentence containing the text <code>\"Tub's World\"</code>. We then use indexing to access the character at position 0, which is <code>'T'</code>. The <code>print()</code> function displays the output, confirming that the first character in the string is indeed <code>'T'</code>.</p> <p>Input<pre><code># String indexing\n# Indexing starts from 0\nsentence = \"Tub's World\"\nprint(sentence[0])\n</code></pre> Output<pre><code>T\n</code></pre></p> <p>Now, let's see how negative indexing works in Python:</p> <p>Input<pre><code># If index is negative, it starts from the end\nsentence = \"Tub's World\"\nprint(sentence[-1])\n</code></pre> Output<pre><code>d\n</code></pre></p> <p>Accessing an index that is out of range will result in an error. Input<pre><code># If we input 11, it will throw an error\nsentence = \"Tub's World\"\nprint(sentence[11])\n</code></pre> Output<pre><code>IndexError: string index out of range\n</code></pre></p>"},{"location":"02_data_types/#223-string-slicing","title":"2.2.3. String Slicing","text":"<p>String slicing is a technique used to extract a subset of characters from a string. Slicing is done by specifying the starting and ending indices of the slice, separated by a colon. The starting index is inclusive, and the ending index is exclusive. If either the starting or ending index is omitted, it defaults to the beginning or end of the string, respectively.</p> <p>Basic Indexing</p> <p>Input<pre><code># The first index is inclusive, the second index is exclusive\nsentence = \"Tub's World\"\n# Index: 012345678910\n# Reverse index: 9876543210\n</code></pre> Basic Syntax<pre><code># string[start:end:step]\nsentence = \"Tub's World\"\n# sentence[index:index:step]\n</code></pre></p> <p>Input<pre><code># The first index is inclusive, the second index is exclusive\nsentence = \"Tub's World\"\n# Index: 012345678910\nprint(sentence[0:3])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Input<pre><code># We can also omit the first index\nsentence = \"Tub's World\"\nprint(sentence[:3])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Input<pre><code># We can also omit the second index\nsentence = \"Tub's World\"\nprint(sentence[3:])\n</code></pre> Output<pre><code>'s World\n</code></pre></p> <p>Input<pre><code># We can also omit both index\nsentence = \"Tub's World\"\nprint(sentence[:])\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>Reverse Slicing</p> <p>If we want to print out the <code>World</code>, we can use reverse indexing to get the last 5 characters: Input<pre><code>sentence = \"Tub's World\"\n# Reverse index: 9876543210\nprint(sentence[-6:-1])\n</code></pre> Output<pre><code>World\n</code></pre></p> <p>Step Size</p> <p>We can also specify a step size to skip characters in the string. The following code demonstrates how to use a step size of 2 to print out every other character in the string:</p> <p>Input<pre><code># Step size\nsentence = \"Tub's World\"\nprint(sentence[::2])\n</code></pre> Output<pre><code>Tb sWrd\n</code></pre></p> <p>We can also specify a step size of 2 to print out every other character in the string, starting from the second character to the : Input<pre><code># Step size\nsentence = \"Tub's World\"\nprint(sentence[1:6:2])\n</code></pre> Output<pre><code>u'\n</code></pre></p> <p>Negative Step Size</p> <p>We can also use a negative step size to reverse the string:</p> <p>Input<pre><code># Negative step size\nsentence = \"Tub's World\"\nprint(sentence[::-1])\n</code></pre> Output<pre><code>dlroW s'buT\n</code></pre></p> <p>We can also print out the same result by using the following code:</p> <p>Input<pre><code>sentence = \"Tub's World\"\nprint(sentence[-1:2:-1])\n</code></pre> Output<pre><code>dlroW s'buT\n</code></pre></p>"},{"location":"02_data_types/#224-count-find-and-replace","title":"2.2.4. <code>count()</code>, <code>find()</code>, and <code>replace()</code>","text":"<p>The <code>count()</code>, <code>find()</code>, and <code>replace()</code> methods are used to count, find, and replace substrings within a string, respectively.</p> <p><code>count()</code> returns the number of occurrences of a specified substring in the given string.</p> <p>Input<pre><code># Count (return the number of occurrences)\nsentence = \"Tub's World\"\nprint(sentence.count('o'))\n</code></pre> Output<pre><code>1\n</code></pre></p> <p><code>find()</code> returns the index of the first occurrence of a specified substring in the given string.</p> <p>Input<pre><code># Find (return the index of the first occurrence)\nsentence = \"Tub's World\"\nprint(sentence.find('o'))\n</code></pre> Output<pre><code>8\n</code></pre></p> <p><code>replace()</code> replaces all occurrences of a specified substring (old) with a new substring in the given string.</p> <p>Input<pre><code># Replace (replace old with new)\nsentence = \"Tub's World\"\nprint(sentence.replace('Tub', 'Tom'))\n</code></pre> Output<pre><code>Tom's World\n</code></pre></p> <p>We can also assign the result of the replace() method back to the same variable if we want to update the original string: Input<pre><code># We can also assign the result to the same variable\nsentence = \"Tub's World\"\nsentence = sentence.replace('Tub', 'Tom')\nprint(sentence)\n</code></pre> Output<pre><code>Tom's World\n</code></pre></p>"},{"location":"02_data_types/#225-string-concatenation","title":"2.2.5. String Concatenation","text":"<p>String concatenation is a technique used to join two or more strings together. In Python, string concatenation is done using the <code>+</code> operator.</p> <p>Input<pre><code># String concatenation\nname = 'Tub'\nage = 5\nsentence = name + 'is' + str(age) + 'years old'\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>String concatenation is essential when working with dynamic content, such as user input or data from external sources, as it enables you to construct meaningful and contextually relevant strings. When concatenating strings, it's essential to pay attention to spaces and punctuation to ensure the resulting string is formatted correctly. For instance, in this example, we've added a space character between the punctuation and noun variables to separate the words in the final string.</p>"},{"location":"02_data_types/#226-string-formatting","title":"2.2.6. String Formatting","text":"<p>String formatting is a technique used to embed values within a string. In Python, there are several ways to format strings, including using the <code>format()</code> method and using f-strings. The <code>format()</code> method allows you to embed values within a string using placeholders, which are represented by curly braces <code>{}</code>. You can also use named placeholders to improve the readability of your code. F-strings are a more recent addition to Python and provide a more concise and intuitive way to embed values within a string.</p> <p>Here, we have three string variables: <code>name</code>, and an integer variable <code>age</code>. We introduce three methods for including non-string variables in a string using string formatting:</p> <p>Input: Setting up variables<pre><code># If we want to concatenate a lot of strings, \n# it is better to use string formatting\nname = 'Tub'\nage = 5\n</code></pre> Method 1: Using the <code>format()</code> method Input<pre><code># Method 1\n# Use format() method\nsentence = '{} is {} years old'.format(name, age)\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>Method 2: Using the <code>format()</code> method with keyword arguments Input<pre><code># Method 2\n# use format() method with keyword arguments\nsentence = '{n} is {a} years old'.format(n=name, a=age)\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>Method 3: Using <code>f</code>-strings (Python 3.6+) Input<pre><code># Method 3\n# Use f-string (3.6+)\nsentence = f'{name} is {age} years old'\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>In addition to the methods above, we can also modify the string content within the string formatting. In this case, we convert the name variable to uppercase using the <code>.upper()</code> method:</p> <p>Input<pre><code># With upper case\nsentence = f'{name.upper()} is {age} years old'\nprint(sentence)\n</code></pre> Output<pre><code>TUB is 5 years old\n</code></pre></p> <p>All three methods allow you to easily include non-string variables in your string, without the need for explicit type conversion, making them more efficient and readable than traditional string concatenation.</p>"},{"location":"02_data_types/#227-dir-and-help","title":"2.2.7. <code>dir()</code> and <code>help()</code>","text":"<p>The <code>dir()</code> function returns a list of all attributes and methods of the specified object, while the <code>help()</code> function provides documentation on a specific attribute or method.</p> <p>We pass the name variable, which is a string, to the dir() function. This will return a list of all available attributes and methods for the string object.</p> <p>Input<pre><code># dir() function returns a list of all \n# attributes and methods of the specified object\nname = 'Tub'\nprint(dir(name))\n</code></pre> Output<pre><code>['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__',\n '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__',\n '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__',\n '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',\n '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find',\n 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower',\n 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans',\n 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',\n 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n</code></pre></p> <p>We can also use <code>help()</code> function to display information about the string variable, but instead of passing the variable name, we pass the string object <code>str</code> itself. </p> <p>Input<pre><code># help() function\nname = 'Tub'\nprint(help(str))\n</code></pre> Output (partial)<pre><code>Help on class str in module builtins:...\n...\n</code></pre></p>"},{"location":"02_data_types/#23-lists","title":"2.3. Lists","text":"<p>Lists in Python are ordered, mutable collections of items. They can store elements of different types, such as strings, integers, or other objects.</p> <p>Creating a list with pet names:</p> <p>Input<pre><code># A list of pets names\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>Create an empty list using the <code>[]</code> or <code>list()</code> function: Input<pre><code># Create empty list\nempty_list = []\n# or\nempty_list = list()\nprint(empty_list)\n</code></pre> Output<pre><code>[]\n</code></pre></p>"},{"location":"02_data_types/#231-list-indexing","title":"2.3.1. List Indexing","text":"<p>Check the length of the list using the <code>len()</code> function: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(len(pet))\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>In Python the first element of a list has index <code>0</code>, which is different from other programming languages, e.g. R, where the first element has index <code>1</code>.</p> <p>Access the first element of the list using the index <code>0</code>:</p> <p>Input<pre><code># Indexing starts from 0\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[0])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Access the last element of the list using the index <code>-1</code>: Input<pre><code># If index is negative, it starts from the end\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[-1])\n</code></pre> Output<pre><code>Barkalot\n</code></pre></p> <p>Access the second element of the list using the index <code>1</code>: Input<pre><code>```python title=\"Input\"\n# If we input 4, it will throw an error\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[4])\n</code></pre> Output<pre><code>IndexError: list index out of range\n</code></pre></p>"},{"location":"02_data_types/#232-list-slicing","title":"2.3.2. List Slicing","text":"<p>Slicing is a way to access a subset of a list. We can use the colon <code>:</code> to specify the start and end index of the slice. The slice will include the start index, but not the end index.</p> <p>Basic Indexing for List Slicing</p> Basic Indexing<pre><code># Index: 0  1  2  3\n# Reverse index : -4 -3 -2 -1\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre> Basic Syntax<pre><code># list[start:end:step]\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\n# pet[index:index:step]\n</code></pre> <p>Slice the first two elements of the list: Input<pre><code># Slicing starts from 0\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[0:2])\n</code></pre> Output<pre><code>['Tub', 'Furrytail']\n</code></pre></p> <p>If we omit the start index, the slice will start from the beginning of the list: Input<pre><code># Omit the first index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[:2])\n</code></pre> Output<pre><code>['Tub', 'Furrytail']\n</code></pre></p> <p>If we omit the end index, the slice will end at the end of the list: Input<pre><code># Omit the second index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[2:])\n</code></pre> Output<pre><code>['Cat', 'Barkalot']\n</code></pre></p> <p>We can also omit both indices to return the entire list: Input<pre><code># Omit both index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[:])\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>Reverse Slicing Recall that the index <code>-1</code> refers to the last element of the list. We can use this to reverse the list: Input<pre><code># Reverse Index: -5, -4, -3, -2, -1\nnumbers_list = [1, 2, 3, 4, 5]\nprint(numbers_list[-3:-1])\n</code></pre> Output<pre><code>[3, 4]\n</code></pre></p> <p>If we want to all the way from the last element to the <code>-3</code> index (not including the <code>-3</code> index), we can omit the last index: Input<pre><code>print(numbers_list[-3:])\n</code></pre> Output<pre><code>[3, 4, 5]\n</code></pre></p> <p>Or we can omit the first index to all the way from the first element to the <code>-3</code> index (not including the <code>-3</code> index): Input<pre><code>print(numbers_list[:-3])\n</code></pre> Output<pre><code>[1, 2]\n</code></pre></p> <p>We can also use positive step size to reverse the list: Input<pre><code>print(numbers_list[1:-2])\n</code></pre> Output<pre><code>[2, 3]\n</code></pre></p> <p>Step Size</p> <p>We can also specify the step size of the slice. For example, we can slice every other element of the list by specifying the step size as <code>2</code>: Input<pre><code>```python title=\"Input\"\nnumbers_list = [1, 2, 3, 4, 5]\n# list[start:end:step]\nprint(numbers_list[0:3:2])\n</code></pre> Output<pre><code>[1, 3]\n</code></pre></p> <p>The default step size is <code>1</code>. We can omit the step size if we want to slice every element of the list:</p> <p>Omit the step size: Input<pre><code>print(numbers_list[0:3])\n</code></pre> Output<pre><code>[1, 2, 3]\n</code></pre></p> <p>With step size <code>1</code>: Input<pre><code>print(numbers_list[0:3:1])\n</code></pre> Output<pre><code>[1, 2, 3]\n</code></pre></p> <p>We can also use negative step size to reverse the list: Input<pre><code>print(numbers_list[0:3:-1])\n</code></pre> Output<pre><code>[]\n</code></pre> However, this will return an empty list. Since the step size is negative number <code>-1</code>, the slice will start from the <code>0</code> index and then move backward to the <code>-1</code> index, which is on the opposite direction of index <code>3</code>. Therefore, it returns an empty list.</p> <p>To fix this, we can reverse the start and end index: Input<pre><code>print(numbers_list[-3::-1])\n</code></pre> Output<pre><code>[3, 2, 1]\n</code></pre></p> <p>We can also omit the start and end index to include the entire list, by a step of <code>-2</code>: Input<pre><code>print(numbers_list[::-2])\n</code></pre> Output<pre><code>[5, 3, 1]\n</code></pre></p>"},{"location":"02_data_types/#232-list-methods","title":"2.3.2. List Methods","text":"<p>There are many methods that can be used with lists. In the following examples, we will introduce couple of common methods to manipulate the list. </p> <p>Add an item to the end of the list using the <code>append()</code> method: Input<pre><code># Add an item to the end of the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.append('Hootsworth ')\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Hootsworth ']\n</code></pre></p> <p>Add an item to a specific index, e.g. <code>2</code>, using the <code>insert()</code> method: Input<pre><code># Add an item to a specific index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.insert(2, 'Fish')\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Fish', 'Cat', 'Barkalot']\n</code></pre></p> <p>Now, we want to insert a list into a list after a specific location, e.g. 0, using the <code>insert()</code> method: Input<pre><code># Insert a list into a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = ['Bumblefluff ', 'Whiskerfloof']\npet.insert(0, pet_2)\nprint(pet)\n</code></pre> Output<pre><code>[['Bumblefluff ', 'Whiskerfloof'], 'Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p><code>insert()</code> method inserts the list as a single element</p> <p>However, this is not what we want because we want to insert the elements of the list <code>pet_2</code> into the list <code>pet</code>. </p> <p>Then we can use the <code>extend()</code> instead to do this: Input<pre><code># Extend a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = ['Bumblefluff ', 'Whiskerfloof']\npet.extend(pet_2)\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Bumblefluff ', 'Whiskerfloof']\n</code></pre> Now, we have successfully inserted the elements of the list <code>pet_2</code> into the list <code>pet</code>.</p> <p>We can remove an item from the list using the <code>remove()</code> method: Input<pre><code># Remove an item from the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.remove('Tub')\nprint(pet)\n</code></pre> Output<pre><code>['Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>We can also remove an item from the list using the <code>pop()</code> method. If we do not specify the index, it will remove the last item from the list: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.pop()\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat']\n</code></pre></p> <p>Or we can specify the index to remove the item at that index: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.pop(1)\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Cat', 'Barkalot']\n</code></pre></p> <p>We can also use the <code>pop()</code> method to get the item that we removed from the list, and assign it to the <code>popped_sp</code> variable: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npopped_pet = pet.pop()\nprint(popped_pet)\n</code></pre> Output<pre><code>Barkalot\n</code></pre> This is very helpful when we have a queue to keep popping until the queue is empty and we want to keep track of the items that we have popped.</p> <p>If we want to search for an index of an item in the list, we can use the <code>index()</code> method: Input<pre><code># Search for an index of an item in the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet.index('Tub'))\n</code></pre> Output<pre><code>0\n</code></pre></p> <p>We can check if the <code>'Tub'</code> is in the pet list using the <code>in</code> keyword: Input<pre><code># If an item is in the list\nprint('Tub' in pet)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Sometimes, we want to join a list of strings into a single string. We can use the <code>join()</code> method to do this: Input<pre><code># Join a list of strings\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_str = ','.join(pet)\nprint(pet_str)\n</code></pre> Output<pre><code>Tub,Furrytail,Cat,Barkalot\n</code></pre></p> <p>Or we can split the single string into a list by a specific character, e.g. <code>,</code>: Input<pre><code># Split a string into a list by ','\npet_str = 'Tub,Furrytail,Cat,Barkalot'\npet_list = pet_str.split(',')\nprint(pet_list)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>When dealing with a list of numbers, we can use the <code>min()</code>, <code>max()</code>, and <code>sum()</code> functions to get the minimum, maximum, and sum of the numbers in the list:</p> <code>min()</code><code>max()</code><code>sum()</code> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(min(nums))\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(max(nums))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(sum(nums))\n</code></pre> Output<pre><code>15\n</code></pre></p>"},{"location":"02_data_types/#233-sorting-and-reversing","title":"2.3.3. Sorting and Reversing","text":"<p>We can reverse a list of strings using the <code>reverse()</code> method in reverse alphabetical order: Input<pre><code># Reverse a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.reverse()\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub']\n</code></pre></p> <p>We can sort a list of strings using the <code>sort()</code> method in alphabetical order: Input<pre><code># Sort a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.sort()\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub']\n</code></pre></p> <p>We can sort a list of numbers using the <code>sort()</code> method in alphabetical order: Input<pre><code>nums = [5, 3, 2, 4, 1]\nnums.sort()\nprint(nums)\n</code></pre> Output<pre><code>[1, 2, 3, 4, 5]\n</code></pre></p> <p>Of course, we can also sort a list of numbers in reverse order by using <code>sort(reverse = True)</code>: Input<pre><code># Instead of using .reverse(), we can use reverse = True\nnums.sort(reverse = True)\nprint(nums)\n</code></pre> Output<pre><code>[5, 4, 3, 2, 1]\n</code></pre></p> <p>However, the above methods <code>sort()</code> and <code>reverse()</code> are changing our original variables. What if we want to keep the original variables? We can use the <code>sorted()</code> function to sort a list of strings in alphabetical order: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nsorted_pet = sorted(pet)\nprint(sorted_pet)\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub'] # sorted_pet\n['Tub', 'Furrytail', 'Cat', 'Barkalot'] # original pet\n</code></pre> Here, we don't change the original variable <code>pet</code> but create a new variable <code>sorted_pet</code> to store the sorted list. This is useful when we want to keep the original list unchanged.</p>"},{"location":"02_data_types/#24-tuples","title":"2.4. Tuples","text":"<p>Tuples are similar to lists, but they are immutable. This means that we cannot change the contents of a tuple once it is created. Tuples are useful when we want to store a list of items that cannot be changed. </p>"},{"location":"02_data_types/#241-creating-a-tuple","title":"2.4.1. Creating a Tuple","text":"<p>Create an empty tuple is similar to creating an empty list, the only difference is that we use <code>()</code> instead of <code>[]</code>, or you can use the <code>tuple()</code> function: Input<pre><code># Create empty tuple\nempty_tuple = ()\n# or\nempty_tuple = tuple()\nprint(empty_tuple)\n</code></pre> Output<pre><code>()\n</code></pre></p> <p>Create a tuple based on the same strings as the list <code>pet</code>: Input<pre><code>pet_tup_1 = ('Tub', 'Furrytail', 'Cat', 'Barkalot')\nprint(pet_tup_1)\n</code></pre> Output<pre><code>('Tub', 'Furrytail', 'Cat', 'Barkalot')\n</code></pre></p>"},{"location":"02_data_types/#25-immutable-vs-mutable","title":"2.5. Immutable vs. Mutable","text":"<p>Immutable means that we cannot change the contents of the object. Mutable means that we can change the contents of the object. </p> <p>Pros and Cons of Immutable</p> Immutable Data TypesMutable Data Types <ul> <li>Numbers</li> <li>Strings</li> <li>Tuples</li> <li>Frozen sets</li> </ul> <ul> <li>Lists</li> <li>Dictionaries</li> <li>Sets</li> </ul> <p>Here's a general overview of the advantages and disadvantages of mutable and immutable objects:</p> <p>Pros and Cons of Immutable</p> Pros of ImmutableCons of Immutable <p>Note</p> <p>Simplicity: Immutability makes the code easier to reason about, as you don't have to worry about unintentional changes to the object.</p> <p>Hashable: Immutable objects can be used as keys in dictionaries, as their content remains constant and their hash values do not change over time.</p> <p>Optimization: Immutable objects allow languages and compilers to perform certain optimizations that can improve the performance of a program.</p> <p>Thread-safety: Immutable objects are inherently thread-safe, as multiple threads cannot modify them simultaneously. This property eliminates the need for locking mechanisms when working with immutable objects in multi-threaded environments.</p> <p>Predictability: When you pass an immutable object to a function, you can be sure that the function will not modify the object, which ensures that the behavior of the program remains predictable.</p> <p>Note</p> <p>Memory overhead: Since each operation on an immutable object creates a new object, it can lead to increased memory usage, especially when manipulating large objects or performing many operations.</p> <p>Performance: Creating new objects for each operation can be slower than modifying objects in-place, particularly in cases where the program performs many operations on objects. In such situations, using mutable data structures may be more efficient.</p> <p>Pros and Cons of Mutable</p> Pros of MutableCons of Mutable <p>Note</p> <p>In-place modification: Mutable objects can be modified in-place, which can lead to better performance and lower memory usage, especially when working with large objects or performing many operations on objects.</p> <p>Flexibility: Mutable objects offer more flexibility in how you can manipulate and change data, which can be helpful in certain scenarios.</p> <p>Note</p> <p>Complexity: Mutable objects can make code harder to reason about, as you need to consider the possibility of unintentional changes to the object.</p> <p>Thread-safety: Mutable objects are not inherently thread-safe, and using them in multi-threaded environments can lead to race conditions and other concurrency-related issues if proper locking mechanisms are not in place.</p> <p>Predictability: When you pass a mutable object to a function, you cannot be sure whether the function will modify the object or not, which can make the behavior of the program less predictable.</p> <p>Not hashable: Mutable objects cannot be used as keys in dictionaries, as their content can change, potentially causing issues with hashing.</p>"},{"location":"02_data_types/#251-string-is-immutable","title":"2.5.1. String is Immutable","text":"<p>Strings in Python are immutable, meaning you cannot change their content directly. Instead, when you perform operations like concatenation, replacement, changing the case, or slicing, you create new strings rather than modifying the original ones.</p> <p>Concatenation</p> <p>Input<pre><code>original_string = \"Hello, \"\npet = \"Tub\"\ngreeting = original_string + pet\nprint(greeting)\nprint('Address of original_string is: {}'.format(id(original_string)))\nprint('Address of greeting is: {}'.format(id(greeting)))\n</code></pre> Output<pre><code>Hello, Tub  \nAddress of original_string is: 2186723937904\nAddress of greeting is: 2186728523312\n</code></pre> As you can see, the memory addresses of the original string and the new string are different, confirming that a new string is created during concatenation.</p> <p>Replace</p> <p>The replace() method in Python is used to replace a specified value with another value in a string. When you use the <code>replace()</code> method, a new string is created, and the original string remains unchanged.</p> <p>Input<pre><code>original_string = \"Hello, World!\"\nnew_string = original_string.replace(\"World\", \"Tub\")\nprint(new_string)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of new_string is:{}'.format(id(new_string)))\n</code></pre> Output<pre><code>Hello, Tub\nAddress of original_string is:1436882337200\nAddress of new_string is:1436885468848\n</code></pre> Again, the memory addresses of the original string and the new string are different, confirming that a new string is created during the replacement.</p> <p>Change the Case</p> <p>Input<pre><code>original_string = \"Tub is awesome!\"\nuppercase_string = original_string.upper()\nprint(uppercase_string)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of uppercase_string is:{}'.format((id(uppercase_string))))\n</code></pre> Output<pre><code>TUB IS AWESOME!\nAddress of original_string is:1923265193776\nAddress of uppercase_string is:1923268233008\n</code></pre> Again, the memory addresses of the original string and the new string are different.</p> <p>Then you may ask what is the advantage of immutable: </p> <p>Slicing When you slice a string, a new string is created, and the original string remains unchanged.</p> <p>Input<pre><code>original_string = \"Tub is cute!\"\nsubstring = original_string[0:3]\nprint(substring)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of substring is:{}'.format(id(substring)))\n</code></pre> Output<pre><code>Tub\nAddress of original_string is:1923265193776\nAddress of substring is:1923268233008\n</code></pre></p>"},{"location":"02_data_types/#251-list-is-mutable","title":"2.5.1. List is Mutable","text":"<p>Input<pre><code>pet_1 = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = pet_1\npet_1[1] = 'Furrytail 2'\nprint(pet_1)\nprint(pet_2)\n</code></pre> Output<pre><code>['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n</code></pre> We can see that when we change the contents of <code>pet_1</code>, the contents of <code>pet_2</code> also change. This is because <code>pet_1</code> and <code>pet_2</code> are both references to the same list in memory.</p> <p>Input<pre><code>print('Address of pet_1 is: {}'.format(id(pet_1)))\nprint('Address of pet_2 is: {}'.format(id(pet_2)))\n</code></pre> Output<pre><code>Address of pet_1 is: 2250825683136\nAddress of pet_2 is: 2250825683136\n</code></pre> The address of <code>pet_1</code> and <code>pet_2</code> are the same, which means they are both references to the same list in memory.</p> <p>Python vs. R in Variable Assignment</p> <p>Python and R handle variable assignment differently, particularly when it comes to mutable objects like lists in Python.</p> <p>In R, when you assign one variable to another, it creates a copy of the original variable's data. This means that if you change one variable's contents, the other variable's contents remain unchanged. This behavior is known as \"copy-on-write\" and allows R to save memory by not duplicating data until it is necessary.</p> <p>In Python, when you assign one variable to another, you are actually creating a reference to the original variable's data, rather than copying the data itself. This means that if you change the contents of one variable, the other variable's contents will also change because they both point to the same data in memory.</p> <p>If you want to create a new list that is a copy of <code>pet_1</code> like that in R and not a reference to <code>pet_1</code>, you can use the <code>copy()</code> method: Input<pre><code>pet_1 = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = pet_1.copy()\npet_1[1] = 'Furrytail 2'\nprint(pet_1)\nprint(pet_2)\n</code></pre> Output<pre><code>['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre> We can see that when we change the contents of <code>pet_1</code>, the <code>pet_2</code> remain unchanged. This is because <code>pet_2</code> refers to a new list that is a copy of <code>pet_1</code>.</p> <p>Input<pre><code>print('Address of pet_1 is: {}'.format(id(pet_1)))\nprint('Address of pet_2 is: {}'.format(id(pet_2)))\n</code></pre> Output<pre><code>Address of pet_1 is: 1704413046016\nAddress of pet_2 is: 1704413120128\n</code></pre> The address of <code>pet_1</code> and <code>pet_2</code> are different.</p>"},{"location":"02_data_types/#252-tuple-is-immutable","title":"2.5.2. Tuple is Immutable","text":"<p>In the other hand, tuple is immutable, so we cannot change the contents of a tuple once it is created. For example, we cannot change the second item <code>Furrytail</code> in the tuple <code>pet_tup_1</code>: Input<pre><code># Immutable\npet_tup_1 = ('Tub', 'Furrytail', 'Cat', 'Barkalot')\npet_tup_1[1] = 'Furrytail 2'\nprint(pet_tup_1)\n</code></pre> Output<pre><code>TypeError: 'tuple' object does not support item assignment\n</code></pre> Here we get an error message <code>TypeError: 'tuple' object does not support item assignment</code> on changing the second item in the <code>pet_tup_1</code> tuple.</p>"},{"location":"02_data_types/#26-dictionaries","title":"2.6. Dictionaries","text":"<p>Dictionaries are similar to lists, but instead of using an index to access an item, we use a key. Dictionaries are unordered, and we cannot sort them. Dictionaries are mutable, so we can change the contents of a dictionary once it is created.</p>"},{"location":"02_data_types/#261-creating-a-dictionary","title":"2.6.1. Creating a Dictionary","text":"<p>Let's create a dictionary that stores one of our old friend <code>'Tub'</code>, its <code>age</code>, and favoriate <code>habitat</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p>"},{"location":"02_data_types/#262-accessing-items-in-a-dictionary","title":"2.6.2. Accessing Items in a Dictionary","text":"<p>We can access the items in a dictionary by using the key <code>'species'</code>, <code>'age'</code>, and <code>'habitat'</code>: Input<pre><code>print(pet['species'])\nprint(pet['age'])\nprint(pet['habitat'])\n</code></pre> Output<pre><code>Tub\n5\n['bathroom', 'kitchen']\n</code></pre></p> <p>Of course, we can use number as the key, but it is not recommended: Input<pre><code>pet = {1: 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet[1])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>What if we accidently acces a key that not exist in the dictionary? Input<pre><code># Access a key that not exist\npet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet['weight'])\n</code></pre> Output<pre><code>KeyError: 'weight'\n</code></pre> We will get an error message <code>KeyError: 'weight'</code>. </p> <p>But practically this is not ideal, sometimes we just want to check if the key is in the dictionary or not without showing error, but return a <code>flag</code>. </p> <p>We can use <code>get()</code> method to do this: Input<pre><code># Get method\npet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.get('age'))\nprint(pet.get('weight'))\n</code></pre> Output<pre><code>5\nNone\n</code></pre> We can see that when we use <code>get()</code> method, if the key is in the dictionary, it will return the value of the key, e.g. <code>5</code>, but if the key is not in the dictionary, it will return <code>None</code>.</p> <p>We can also specify a default value to return if the key is not in the dictionary instead of <code>None</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.get('weight', 'Not there'))\n</code></pre> Output<pre><code>Not there\n</code></pre></p>"},{"location":"02_data_types/#263-changing-items-in-a-dictionary","title":"2.6.3. Changing Items in a Dictionary","text":"<p>We can update the value of a key, e.g. <code>'weight'</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet['weight'] = 2000\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen'], 'weight': 2000}\n</code></pre></p> <p>We can also use <code>update()</code> to update the values from keys in a dictionary: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet.update({'weight': 1000, 'name': 'Fluffy', 'age': 6})\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 6, 'habitat': ['bathroom', 'kitchen'], 'weight': 1000, 'name': 'Fluffy'}\n</code></pre></p> <p>While if we want to delete the key <code>'age'</code> and its value from the dictionary, we can use <code>del</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\ndel pet['age']\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p> <p>Or use <code>pop()</code>:  Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet.pop('age')\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p> <p>We can also assign the popped value to a variable: Input<pre><code>popped_age = pet.pop('age')\nprint(pet)\nprint(popped_age)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n5\n</code></pre> This can be useful if we want to use the popped value later.</p> <p>As we mentioned in the previous sections, <code>len()</code> can also be used to check how many keys in a dictionary: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(len(pet))\n</code></pre> Output<pre><code>3\n</code></pre></p>"},{"location":"02_data_types/#264-accessing-keys-and-values","title":"2.6.4. Accessing Keys and Values","text":"<p>We can access all the keys from a dictionary using <code>keys()</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.keys())\n</code></pre> Output<pre><code>dict_keys(['species', 'age', 'habitat'])\n</code></pre></p> <p>We can also access all the values from a dictionary using <code>values()</code>: Input<pre><code>print(pet.values())\n</code></pre> Output<pre><code>dict_values(['Tub', 5, ['bathroom', 'kitchen']])\n</code></pre></p> <p>If we want to access the key-value pairs, we can use <code>items()</code>: Input<pre><code>print(pet.items())\n</code></pre> Output<pre><code>dict_items([('species', 'Tub'), ('age', 5), ('habitat', ['bathroom', 'kitchen'])])\n</code></pre> This is convenient if we want to loop through the key-value pairs.</p>"},{"location":"02_data_types/#27-sets","title":"2.7. Sets","text":"<p>Sets are unordered collections of unique elements and are useful when we want to store a collection of items that are not in any particular order and we don't want to store duplicate items.</p>"},{"location":"02_data_types/#271-creating-a-set","title":"2.7.1. Creating a Set","text":"<p>Create an empty set is similar to creating an empty list, you can use <code>set()</code>. Although the brackets <code>{}</code> are also used to create a set, it is actually creating an empty dictionary. To create an empty set, you need to use <code>set()</code>: Input<pre><code>empty_dict = {} # This is to create an empty dictionary\nempty_set = set() # This is to create an empty set\nprint(type(empty_dict))\nprint(empty_set)\nprint(type(empty_set))\n</code></pre> Output<pre><code>&lt;class 'dict'&gt;\nset()\n&lt;class 'set'&gt;\n</code></pre></p> <p>Create a set based on the same strings as the list <code>pet</code>: Input<pre><code>pet = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\nprint(type(pet))\nprint(pet)\n</code></pre> Output<pre><code>&lt;class 'set'&gt;\n{'Tub', 'Cat', 'Barkalot', 'Furrytail'}\n</code></pre></p> <p><code>set</code> Doesn't Care About Order</p> <p>Notice that the order of the elements in the set is different from the order of the elements in the list <code>pet</code>. This is because sets are unordered collections of unique elements. If you run it multiple times, the order will be different as sets don't care about the order of the elements.</p>"},{"location":"02_data_types/#272-set-methods","title":"2.7.2. Set Methods","text":"<p>If we create a set with duplicate elements, the set will only keep one copy of the element: Input<pre><code># Sets throw away the duplicate elements.\npet = {'Tub', 'Furrytail', 'Cat', 'Barkalot', 'Tub'}\nprint(pet)\n</code></pre> Output<pre><code>{'Tub', 'Cat', 'Barkalot', 'Furrytail'}\n</code></pre></p> <p>Sets are optimized for checking whether an element is contained in the set. Input<pre><code>pet = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\nprint('Tub' in pet)\nprint('Tub' not in pet)\n</code></pre> Output<pre><code>True\nFalse\n</code></pre></p> <p>We can check if two sets of pet in common using <code>intersection()</code>: Input<pre><code># What these pet have in common\npet_1 = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\npet_2 = {'Tub', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\nprint(pet_1.intersection(pet_2))\n</code></pre> Output<pre><code>{'Tub', 'Furrytail'}\n</code></pre></p> <p>We can also check if two sets of pet not in common using <code>difference()</code>: Input<pre><code># What these pet don't have in common\npet_1 = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\npet_2 = {'Tub', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\nprint(pet_1.difference(pet_2))\n</code></pre> Output<pre><code>{'Cat', 'Barkalot'}\n</code></pre></p> <p>Finally, we can also union both of the sets using <code>union()</code>: Input<pre><code># What these pet have in common and what they don't have in common\nprint(pet_1.union(pet_2))\n</code></pre> Output<pre><code>{'Tub', 'Cat', 'Barkalot', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\n</code></pre></p>"},{"location":"03_control_functions/","title":"3. Control and Functions","text":""},{"location":"03_control_functions/#31-conditionals-and-booleans","title":"3.1. Conditionals and Booleans","text":"<p><code>if</code> statements are used to control the flow of the program. It allows us to execute a block of code if a certain condition is met. <code>else</code> statements are used to execute a block of code if the condition is not met. <code>elif</code> is to add more conditions to the <code>if</code> statement, which stands for <code>else if</code>.</p>"},{"location":"03_control_functions/#311-if-and-boolean-values","title":"3.1.1. <code>if</code> and Boolean Values","text":"<p>Input<pre><code>if True:\nprint(\"It's true!\")\n</code></pre> Output<pre><code>It's true!\n</code></pre></p> <p>What if we change the condition to <code>False</code>? Input<pre><code>if False:\nprint(\"It's true!\")\n</code></pre> Output<pre><code># Nothing will be printed\n</code></pre> This is because that the condition is <code>False</code>, so the block of code is not executed.</p> <p>In real practice, we don't hardcode the condition to be <code>True</code> or <code>False</code>, we basically assess the condition to be <code>True</code> or <code>False</code></p> <p>For example, we can use comparison operators to compare two values: Input<pre><code>pet = 'Tub'\nif pet == 'Tub':\nprint(\"It's true!\")\n</code></pre> Output<pre><code>It's true!\n</code></pre></p> <p>Comparison Operators</p> <p>Recall the operator we used in the previous chapter. This time, we use them in the condition, plus the identity operator <code>is</code>.</p> <ul> <li>Equal: <code>==</code></li> <li>Not Equal: <code>!=</code></li> <li>Greater Than: <code>&gt;</code></li> <li>Less Than: <code>&lt;</code></li> <li>Greater or Equal: <code>&gt;=</code></li> <li>Less or Equal: <code>&lt;=</code></li> <li>Identity: <code>is</code></li> </ul>"},{"location":"03_control_functions/#312-if-else-and-elif","title":"3.1.2. <code>if</code>, <code>else</code>  and <code>elif</code>","text":"<p>Let's continue on the previous example. We campare <code>pet</code> and <code>Tub</code> to see if the pet is <code>Tub</code></p> <p>Input<pre><code>pet = 'Tub'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is Tub!\n</code></pre></p> <p>If we change the value of <code>pet</code> to <code>Barkalot</code>, the condition is not met, so the <code>else</code> statement is executed. Input<pre><code>pet = 'Barkalot'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is not Tub!\n</code></pre></p> <p>We can also use <code>elif</code> to add more conditions to the <code>if</code> statement. Here we have two conditions, <code>pet == 'Tub'</code> and <code>pet == 'Barkalot'</code>. If the first condition is not met, we move on to the next condition. If the second condition is not met, we move on to the <code>else</code> statement:</p> <p>Input<pre><code>pet = 'Barkalot'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelif pet == 'Barkalot':\nprint(\"Pet is Barkalot!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is Barkalot!\n</code></pre></p>"},{"location":"03_control_functions/#313-is-vs","title":"3.1.3. <code>is</code> vs. <code>==</code>","text":"<p>Now, we investigate the difference between <code>is</code> and <code>==</code>:</p> <ul> <li> <p><code>is</code> checks if two variables point to the same object in memory.</p> </li> <li> <p><code>==</code> checks if the values of two variables are equal.</p> </li> </ul> <p>Here, we have two list with the same values. </p> <p>Input<pre><code>pet_1 = ['Tub', 'Barkalot', 'Furrytail']\npet_2 = ['Tub', 'Barkalot', 'Furrytail']\n</code></pre> We use <code>==</code> to compare them, and the result is <code>True</code>.  Input<pre><code>print(pet_1 == pet_2)\n</code></pre> Output<pre><code>True\n</code></pre> This is because that the values of the two lists are the same.</p> <p>If we use <code>is</code> to compare them, the result is <code>False</code>. Input<pre><code>print(pet_1 is pet_2)\n</code></pre> Output<pre><code>False\n</code></pre> The reason is that <code>pet_1</code> and <code>pet_2</code> point to different objects in memory.</p> <p>We can check out the memory address of the two objects using <code>id()</code>: Input<pre><code>print(id(pet_1))\nprint(id(pet_2))\n</code></pre> Output<pre><code>2398480322752\n2398482691520\n</code></pre> You can see that the memory addresses are different.</p> <p>But if we assign <code>pet_2</code> to <code>pet_1</code>, they will point to the same object in memory, and of course have the same values. Input<pre><code>pet_2 = pet_1\nprint(pet_1 == pet_2)\nprint(pet_1 is pet_2)\n</code></pre> Output<pre><code>True\nTrue\n</code></pre> Now, the memory addresses are the same:</p>"},{"location":"03_control_functions/#314-and-or-and-not","title":"3.1.4. <code>and</code>, <code>or</code> and <code>not</code>","text":"<p>We can use <code>and</code> and <code>or</code> to combine conditions. </p> <ul> <li> <p><code>and</code> means both conditions must be met</p> </li> <li> <p><code>or</code> means at least one condition must be met</p> </li> </ul> <p>For example, we want to check if both the account name is <code>Tub</code> and the passcode is correct by using <code>and</code>: Input<pre><code>account_name = 'Tub'\naccount_passcode = True\nif account_name == 'Tub' and account_passcode:\nprint(\"Login successful!\")\nelse:\nprint(\"Login failed!\")\n</code></pre> Output<pre><code>Login successful!\n</code></pre></p> <p>If we want to know if at least one of the account name or account passcode is correct, we use <code>or</code>: Input<pre><code>account_name = 'Tub'\naccount_passcode = True\nif account_name == 'Tub' or account_passcode:\nprint(\"Name or passcode is correct!\")\nelse:\nprint(\"Name and passcode are incorrect!\")\n</code></pre> Output<pre><code>Name or passcode is correct!\n</code></pre></p> <p>If we want to negate a condition, we use <code>not</code>. </p> <ul> <li><code>not</code> means the condition must not be met Input<pre><code>account_passcode = True\nif not account_passcode:\nprint(\"Please enter your passcode!\")\nelse:\nprint(\"Login successful!\")\n</code></pre> Output<pre><code>Login successful!\n</code></pre> Here, we use <code>not</code> to negate the condition <code>account_passcode == True</code> to <code>account_passcode == False</code>.  Therefore, the condition must not be met, and the <code>else</code> statement is not executed. </li> </ul> <p>If we remove <code>not</code>, the condition must be met, which is <code>account_passcode == True</code>, and the <code>if</code> statement is executed.  Input<pre><code>account_passcode = True\nif account_passcode:\nprint(\"Please enter your passcode!\")\nelse:\nprint(\"Login successful!\")\n</code></pre> Output<pre><code>Please enter your passcode!\n</code></pre></p>"},{"location":"03_control_functions/#315-in-and-not-in","title":"3.1.5. <code>in</code> and <code>not in</code>","text":"<p>We can use <code>in</code> to check if a value is in a list. </p> <ul> <li> <p><code>in</code> means the value must be in the list</p> </li> <li> <p><code>not in</code> means the value must not be in the list</p> </li> </ul> <p>Here is the example of <code>in</code>: Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nif 'Tub' in pets:\nprint(\"Tub is in the list!\")\nelse:\nprint(\"Tub is not in the list!\")\n</code></pre> Output<pre><code>Tub is in the list!\n</code></pre></p> <p>If we use <code>not in</code>, the condition is negated, and the <code>else</code> statement is executed: Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nif 'Tub' not in pets:\nprint(\"Tub is not in the list!\")\nelse:\nprint(\"Tub is in the list!\")\n</code></pre> Output<pre><code>Tub is in the list!\n</code></pre></p>"},{"location":"03_control_functions/#316-false-values","title":"3.1.6. False Values","text":"<p>False Values</p> <p>In Python, the following values are considered as <code>False</code>:</p> <ul> <li><code>False</code></li> <li><code>None</code></li> <li><code>0</code> (any zero numeric types)</li> <li>Empty sequence. e.g., <code>''</code>, <code>()</code>, <code>[]</code>.</li> <li>Empty mapping. e.g., <code>{}</code>.</li> </ul> <p><code>False</code> is considered as False: Input<pre><code>account_name = False\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p><code>None</code> is considered as False: Input<pre><code>account_name = None\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Only number <code>0</code> is considered as False: Input<pre><code>account_name = 0\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Empty sequences, e.g. <code>''</code>, <code>()</code>, <code>[]</code>, are considered as False: Input<pre><code>account_name = ''\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Empty dictionary is considered as False Input<pre><code>account_name = {}\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p>"},{"location":"03_control_functions/#32-functions","title":"3.2. Functions","text":"<p>In this section, we will walk you through various examples related to functions in Python, exploring different concepts such as defining and calling functions, arguments, default values, and more.</p>"},{"location":"03_control_functions/#321-functions-basics","title":"3.2.1. Functions Basics","text":"<p>First, let's define a simple function called hello_tub: Input<pre><code>def hello_tub():\npass\nprint(hello_tub)\n</code></pre></p> <p>Output<pre><code>&lt;function hello_world at 0x000001E5F1F9B790&gt;\n</code></pre> This function does nothing, as it contains a pass statement. When you print the function, you will get the memory address of the function object:</p> Input<pre><code>print(hello_tub())\n</code></pre> <p>Output<pre><code>None\n</code></pre> Calling the function with <code>hello_tub()</code> returns None, as the function has no return statement.</p> <p>Now, let's modify the hello_tub function to print a greeting: Input<pre><code>def hello_tub():\nprint('Hello Tub')\nhello_tub()\n</code></pre></p> Output<pre><code>Hello Tub\n</code></pre> <p>Using functions is advantageous when you want to reuse code. For instance, if you want to change the greeting from <code>Tub</code> to <code>Barkalot</code>, you only need to modify the function's implementation, and all the calls to the function will use the updated greeting.</p> <p>For example, if we want to call <code>Hello Tub</code> twice, we can do the following: Input<pre><code>print('Hello Tub')\nprint('Hello Tub')\n</code></pre> Output<pre><code>Hello Tub\nHello Tub\n</code></pre> But this is not convenient, as we have to repeat the same code twice. Instead, we can define a function and call it twice, and even if we want to change both <code>Tub</code>:</p> <p>Input<pre><code>def hello_tub():\nprint('Hello Barkalot')\nhello_tub()\nhello_tub()\n</code></pre> Output<pre><code>Hello Barkalot\nHello Barkalot\n</code></pre></p> <p>Functions can also return values, take parameters, and have default values for parameters. Here are some examples:</p> <p>Input<pre><code>def hello_tub():\nreturn 'Hello Tub'\nprint(hello_tub())\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>We can also call the function with a method, e.g. <code>lower()</code>, to convert the returned value to lowercase:</p> <p>Input<pre><code>print(hello_tub().lower())\n</code></pre> Output<pre><code>hello tub\n</code></pre></p> <p>Functions can also return values, take parameters, and have default values for parameters. Here are some examples:</p> <p>Input<pre><code>def hello_tub(name):\nreturn 'Hello ' + name\nprint(hello_tub('Tub'))\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>Input<pre><code>def hello_tub(name):\nreturn 'Hello {}'.format(name)\nprint(hello_tub('Tub'))\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>We set up a default value for the name parameter, so that if we don't pass a value for name, the function will use the default value: Input<pre><code>def hello_tub(greeting, name = 'Tub'):\nreturn '{}, {}'.format(greeting, name)\nprint(hello_tub('Hello'))\n</code></pre> Output<pre><code>Hello, Tub\n</code></pre></p> <p>When we pass a value for name, the default value is ignored: Input<pre><code>print(hello_tub('Hello', 'Barkalot'))\n</code></pre> Output<pre><code>Hello, Barkalot\n</code></pre></p>"},{"location":"03_control_functions/#322-positional-arguments","title":"3.2.2. Positional Arguments","text":"<p>In Python, non-default arguments (those without default values) must be defined before default arguments (those with default values). In the given code, the greeting parameter has a default value, while name does not. This causes a SyntaxError.</p> <p>Input<pre><code>def hello_tub(greeting = 'Hello', name):\nreturn '{}, {}'.format(greeting, name)\n</code></pre> Output<pre><code>SyntaxError: non-default argument follows default argument\n</code></pre></p> <p>To fix this issue, you should move the non-default argument before the default argument:</p> <p>Input<pre><code>def hello_tub(name, greeting='Hello'):\nreturn '{}, {}'.format(greeting, name)\n</code></pre> Now, the function works as expected, and you can call it with or without providing a greeting argument:</p> <p>Input<pre><code>print(hello_tub('Tub'))\nprint(hello_tub('Tub', 'Hi'))\n</code></pre> Output<pre><code>Hello, Tub\nHi, Tub\n</code></pre></p> <p>Below let's go through a real example how to find the number of days in a month</p> <p>Example - Find the number of days in a month</p> <p>Credits: Python Standard Library, and Corey Schafer.</p> <p>Number of days per month. First value placeholder for indexing purposes.</p> <p>month_days<pre><code>month_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n</code></pre> The <code>is_leap()</code> function takes a year as input and returns True if it's a leap year, and False otherwise. Leap years are those divisible by 4, but not divisible by 100, unless they are also divisible by 400.</p> <p>is_leap()<pre><code>def is_leap(year):\n\"\"\"\n    Return True for leap years, False for non-leap years.\n    \"\"\"\nreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n</code></pre> The <code>days_in_month()</code> function takes a year and a month as input and returns the number of days in that month for that year. It checks if the input year is a leap year and adjusts the number of days in February accordingly. If an invalid month is provided, it returns <code>Invalid Month</code>.</p> <p>days_in_month()<pre><code>def days_in_month(year, month):\n\"\"\"\n    Return number of days in that month in that year.\n    \"\"\"\nif not 1 &lt;= month &lt;= 12:\nreturn 'Invalid Month'\nif month == 2 and is_leap(year):\nreturn 29\nreturn month_days[month]\n</code></pre> Finally, the code demonstrates calling the <code>is_leap()</code> and <code>days_in_month()</code> functions with specific inputs:</p> <p>Print<pre><code>print(is_leap(2023))\nprint(days_in_month(2023, 4))\n</code></pre> Output<pre><code>False\n30\n</code></pre></p>"},{"location":"03_control_functions/#323-args-and-kwargs","title":"3.2.3. <code>*args</code> and <code>**kwargs</code>","text":"<p>In the following code, there are several concepts being illustrated: <code>*args</code>, <code>**kwargs</code>, and two custom functions <code>is_leap()</code> and <code>days_in_month()</code>.</p> <p><code>*args</code> and <code>**kwargs</code> are used in function definitions to allow passing a variable number of arguments. <code>*args</code> is used for passing a variable number of non-keyword (positional) arguments, while <code>**kwargs</code> is used for passing a variable number of keyword arguments.</p> <p>Input<pre><code>def pet_info(*args, **kwargs):\nprint(args)\nprint(kwargs)\npet_info('Tub', 'Barkalot', 'Furrytail', pet1 = 'Tub', pet2 = 'Barkalot', pet3 = 'Furrytail')\n</code></pre> Output<pre><code>('Tub', 'Barkalot', 'Furrytail')\n{'pet1': 'Tub', 'pet2': 'Barkalot', 'pet3': 'Furrytail'}\n</code></pre> In the <code>pet_info()</code> function, both <code>*args</code> and <code>**kwargs</code> are used. When you call the function with different types of arguments, you can see how they are grouped and printed:</p> <p>Input<pre><code>def pet_info(*args, **kwargs):\nprint(args)\nprint(kwargs)\nfavorite_food = ['Carrot', 'Brocolli', 'Ice Cream']\ninfo = {'name': 'Tub', 'age': 25}\npet_info(favorite_food, info)\n</code></pre> In the first call to pet_info, we pass a list <code>favorite_food</code> and a dictionary info as arguments without using the <code>*</code> or <code>**</code> unpacking operators. This means the entire list and dictionary are treated as single positional arguments. The output shows that args contains a tuple with two elements: the list <code>favorite_food</code> and the dictionary info. Since we didn't provide any keyword arguments, kwargs is an empty dictionary.</p> Output<pre><code>(['Carrot', 'Brocolli', 'Ice Cream'], {'name': 'Tub', 'age': 25})\n{}\n</code></pre> <p>In the second call to pet_info, we use the <code>*</code> and <code>**</code> unpacking operators to pass the list favorite_food and the dictionary info as individual elements. The <code>*</code> operator unpacks the list elements as positional arguments, and the <code>**</code> operator unpacks the dictionary items as keyword arguments. In this case, the output shows that args contains a tuple with three elements ('<code>Carrot</code>', '<code>Brocolli</code>', '<code>Ice Cream</code>') and kwargs contains a dictionary with the keys and values from the info dictionary.</p> <p>Input<pre><code>pet_info(*favorite_food, **info)\n</code></pre> Output<pre><code>('Carrot', 'Brocolli', 'Ice Cream')\n{'name': 'Tub', 'age': 25}\n</code></pre></p>"},{"location":"03_control_functions/#323-variable-scope-legb-rule","title":"3.2.3. Variable Scope - LEGB rule","text":"<p>In this section, we are discussing variable scope in Python, which determines where a variable can be accessed or modified. Python searches for a variable following the LEBG rule and order: Local, Enclosing, Global, and Built-in.</p> <p>Local A variable defined within a function has local scope. It can only be accessed inside that function.</p> <p>Input<pre><code>def test():\ny = 'local variable y'\nprint(y)\ntest()\n</code></pre> Output<pre><code>local variable y\n</code></pre></p> <p>Global</p> <p>A variable defined outside any function has global scope. It can be accessed both inside and outside of functions.</p> <p>In the following example, we define a variable <code>x</code> outside of the <code>test()</code> function. We can access and modify this variable inside the function. </p> <p>Input<pre><code>x = 'global variable x'\ndef test():\ny = 'local variable y'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>global variable x\nglobal variable x\n</code></pre> Here the results are the same because we are accessing the global variable <code>x</code> inside the function. However, if we try to access the local variable <code>y</code> outside of the function, we get an error.</p> <p>Input<pre><code>print(y)\n</code></pre> Output<pre><code>NameError: name 'y' is not defined\n</code></pre></p> <p>What if we have a variable with the same name inside and outside of a function? In this case, the local variable takes precedence over the global variable. The following example demonstrates this:</p> <p>Input<pre><code>x = 'global variable x'\ndef test():\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nglobal variable x\n</code></pre> This example shows that the python searches for a variable in the local scope first. If it doesn't find it, it searches the global scope. This is the reason that we get the local variable <code>x</code> inside the function first and the global variable <code>x</code> next</p> <p>If it doesn't find it there, it will throw an error. </p> <p>In the next example, we demonstrate how to use the global keyword to change the value of a global variable within a function. </p> <p>Input<pre><code># What if we want to set a new global x\nx = 'global variable x'\ndef test():\nglobal x\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nlocal variable x\n</code></pre></p> <p>In this example, we use the <code>global</code> keyword to change the value of the global variable <code>x</code> inside the function, although this is not recommended in the practice because it can lead to unexpected behavior and make the code difficult to debug and review. </p> <p>You can also do the following:</p> <p>Input<pre><code>def test():\nglobal x\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nlocal variable x\n</code></pre></p> <p>However, it is not recommended to use global often.</p> <p>Input<pre><code>def test(z):\nprint(z)\ntest('local variable z')\nprint(z)\n</code></pre> Output<pre><code>local variable z\nNameError: name 'z' is not defined\n</code></pre></p> <p>Built-in</p> <p>In this example, we are discussing the built-in scope in Python. Built-in scope refers to the predefined functions and variables available in Python, which are part of the standard library.</p> <p>Python has a set of built-in functions, like min(), max(), print(), etc., which are readily available for use.</p> <p>Input<pre><code># Built-in\nimport builtins\n# print(dir(builtins))\nminimum = min([1,2,3])\nprint(minimum)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>However, you should avoid overwriting built-in functions with your own functions or variables. Doing so can lead to errors or unintended behavior.</p> <p>Input<pre><code># If we overwrite the built-in function min()\ndef min():\npass\nm = min([1,2,3])\nprint(m)\n</code></pre> Output<pre><code>TypeError: min() takes 0 positional arguments but 1 was given\n</code></pre></p> <p>To avoid conflicts with built-in functions, it's a good practice to use different names for your own functions. </p> <p>So the best way to do this is to use a different name instead of the default name <code>min()</code>.</p> <p>Input<pre><code>def find_min():\npass\nminimum = min([1,2,3])\nprint(minimum)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>Being mindful of built-in functions and avoiding name conflicts will help you write clean, error-free code.</p> <p>Enclosing</p> <p>In this example, we discuss the concept of enclosing scope in Python. Enclosing scope is the scope of variables that are defined in an outer function but not in the global scope. Enclosing scope variables are accessible from the inner function.</p> <p>Let's look at an example:</p> <p>Input<pre><code>x = 'global variable x'\ndef outer():\nx = 'local-outer variable x'\ndef inner():\nx = 'local-inner variable x'\nprint(x) # 1st print\ninner() # 1st call for 1st print\nprint(x) # 2nd print\nouter() # 2nd call for 1st print and 2nd print\nprint(x) # 3rd print\n</code></pre> Output<pre><code>local-inner variable x\nlocal-outer variable x\nglobal variable x\n</code></pre></p> <p>The <code>outer()</code> function has its own local variable <code>x</code>, and the <code>inner()</code> function also has its own local variable x. When we call the functions, the inner function prints its local variable <code>x</code>, the outer function prints its local variable <code>x</code>, and then the global variable x is printed.</p> <p>Now let's use the nonlocal keyword to modify the enclosing variable from the inner function:</p> <p>Input<pre><code>x = 'global variable x'\ndef outer():\nx = 'local-outer variable x'\ndef inner():\nnonlocal x # Make our local-inner variable x to be the enclosing variable x\nx = 'local-inner variable x'\nprint(x)\ninner()\nprint(x)\nouter()\nprint(x)\n</code></pre> Output<pre><code>local-inner variable x\nlocal-inner variable x\nglobal variable x\n</code></pre></p> <p>In this case, we use the nonlocal keyword inside the <code>inner()</code> function to indicate that we want to modify the enclosing variable <code>x</code> (the one defined in the <code>outer()</code> function) instead of creating a new local variable. When the functions are called, both the inner and outer functions print the modified enclosing variable <code>x</code>, and then the global variable <code>x</code> is printed.</p>"},{"location":"04_advanced_formatting/","title":"4. Advanced Formatting","text":"<p>In Chapter 2, we have seen the basic string formatting. In this chapter, we will see some more advanced formatting examples upon on that.  </p>"},{"location":"04_advanced_formatting/#41-formatting-with-placeholders","title":"4.1. Formatting with placeholders","text":"<p>Let's see the following example first:  Input<pre><code>species_1 = {'species': 'Tub', 'age': 5}\nsentence = 'My name is ' + species_1['species'] + ' and I am ' + str(species_1['age']) + ' years old.'\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> We can see there are a lot of blank space we have to manually put in the beginning and the end of each string.  We also have to cast the integer/number, <code>species_1['age']</code>, into strings by using <code>str()</code>. </p> <p>Of course, there is a better way to do this:  Input<pre><code>sentence = 'My name is {} and I am {} years old.'.format(species_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> We can see that we don't have to cast the integer/number into strings anymore.</p> <p>We can also use the index of the placeholder to specify the order of the arguments: Input<pre><code>sentence = 'My name is {0} and I am {1} years old.'.format(species_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre></p> <p>This is another example using the index of the placeholder with repeated arguments: Input<pre><code>tag = 'p'\ntext = 'This is a paragraph'\nsentence = '&lt;{0}&gt;{1}&lt;/{0}&gt;'.format(tag, text)\nprint(sentence)\n</code></pre> Output<pre><code>&lt;p&gt;This is a paragraph&lt;/p&gt;\n</code></pre></p> <p>This is very useful when we have a placeholder that you want to reuse. Let's see another example: Input<pre><code>sentence = 'My name is {0} and I am {1} years old. My friend Barkalot is also {1} years old.'.format(\nspecies_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old. My friend Barkalot is also 5 years old.\n</code></pre></p> <p>There is another way to do this by using the key in the placeholder instead of the index: Input<pre><code>sentence = 'My name is {0[species]} and I am {1[age]} years old.'.format(species_1, species_1)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> Here, we call the value of the key <code>species</code> in the dictionary <code>species_1</code> by using <code>{0[species]}</code>.</p> <p>But this is redundant because we have to repeat the same argument twice.</p> <p>We can do the following instead: Input<pre><code>sentence = 'My name is {0[species]} and I am {0[age]} years old.'.format(species_1)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre></p> <p>We can also use the index of a list in the placeholder: Input<pre><code>species = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nsentence = 'I am {0[1]} and my friend is {0[3]}.'.format(species)\nprint(sentence)\n</code></pre> Output<pre><code>I am Furrytail and my friend is Barkalot.\n</code></pre></p> <p>We can also access the attributes of an object in the same way. For example, we define a class called <code>Species</code> that represents a species with a <code>species</code> and an <code>age</code>. The class has an <code>__init__</code> method that initializes the instance variables species and age. We then create an instance of the <code>Species</code> class called <code>species_new</code> with the name 'Jerry' and the age <code>88</code>.</p> <p>You then create an instance of the Species class called species_new with the name 'Jerry' and the age 88. Input<pre><code>class Species:\ndef __init__(self, species, age):\nself.species = species\nself.age = age\nspecies_new = Species('Jerry', 88)\n</code></pre> Now we can access the attributes of the object <code>species_new</code> by using the index of the placeholder: Input<pre><code>sentence = 'My name is {0.species} and I am {0.age} years old.'.format(species_new)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Jerry and I am 88 years old.\n</code></pre> The string contains placeholders <code>{0.species}</code> and <code>{0.age}</code> which will be replaced by the species and age attributes of the <code>species_new</code> object. The <code>0</code> in the placeholders refers to the first argument passed to the <code>.format()</code> method, which is <code>species_new</code>.</p> <p>This time, we are using keyword arguments to pass the values that will replace the placeholders in the string. The string contains placeholders <code>{species}</code> and <code>{age}</code>, which will be replaced by the values provided as keyword arguments in the <code>.format()</code> method.</p> <p>Input<pre><code>sentence = 'My name is {species} and I am {age} years old.'.format(species='Jerry', age=88)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Jerry and I am 88 years old.\n</code></pre></p>"},{"location":"04_advanced_formatting/#42-in-format","title":"4.2. <code>**</code> in `.format()","text":"<p>In the format() method, the ** operator can be used to unpack a dictionary that contains the keyword arguments for the placeholders in the string. This can be a convenient way to format a string using a dictionary that has keys matching the placeholders in the string.</p> <p>Here's an example: Input<pre><code>pet = {'species': 'Tub', 'age': 5}\nsentence = 'My name is {species} and I am {age} years old.'.format(**pet)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> In this example, we have a dictionary <code>pet</code> containing the keys <code>species</code> and <code>age</code>. We then use the <code>**</code> operator to unpack the dictionary when calling the <code>.format()</code> method on the string. The values from the dictionary are used to replace the placeholders in the string, resulting in the sentence <code>\"My name is Tub and I am 5 years old.\"</code></p> <p>This method is useful when we print out the dictionaries, which is more readable.</p> <p>why use <code>**species</code> instead of <code>species</code>?</p> <p>When you use <code>**</code> before a dictionary in a function call, like in the <code>.format()</code> method, it is known as dictionary unpacking. It allows you to pass the key-value pairs in the dictionary as named (keyword) arguments to the function.</p> <p>When a dictionary is passed as a keyword argument in this way, the keys in the dictionary are treated as the parameter names and the corresponding values are passed as the parameter values.</p> <p>So, in this case, the keys in the <code>pet</code> dictionary (<code>'species'</code> and <code>'age'</code>) are treated as parameter names in the sentence string, and their corresponding values (<code>'Tub'</code> and <code>5</code>) are passed as parameter values.</p> <p>If you were to pass the pet dictionary without the double asterisks, like so:</p> <p>Input<pre><code>sentence = 'My name is {species} and I am {age} years old.'.format(species)\nprint(sentence)\n</code></pre> Output<pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'species'\n</code></pre></p> <p>The <code>.format()</code> method would be looking for a single argument that is a dictionary, rather than separate keyword arguments, and would raise a TypeError.</p>"},{"location":"04_advanced_formatting/#43-formatting-numbers","title":"4.3. Formatting Numbers","text":"<p>In this block, we are using the <code>.format()</code> method to insert values into a string. The <code>{}</code> serves as a placeholder for the value that will be inserted. The output will be a series of strings with the respective values from the loop.</p> <p>Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 1\nThe value is 2\nThe value is 3\nThe value is 4\nThe value is 5\n</code></pre></p> <p>Padding with zeros (width 2): In this block, we're using the :02 format specifier within the placeholder to pad the value with zeros, ensuring a minimum width of 2 characters. This is useful for maintaining consistent formatting when dealing with numbers of varying lengths. Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {:02}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 01\nThe value is 02\nThe value is 03\nThe value is 04\nThe value is 05\n</code></pre></p> <p>Padding with zeros (width 3): Similarly, we can use the :03 format specifier to pad the value with zeros, ensuring a minimum width of 3 characters. This results in a more extensive padding for the smaller numbers, keeping the output format consistent. Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {:03}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 001\nThe value is 002\nThe value is 003\nThe value is 004\nThe value is 005\n</code></pre></p> <p>By using <code>:.2f</code> within the placeholder, we can format a floating-point number to display two decimal places.</p> <p>Input<pre><code># We can also use the `:.2f` with two decimal places\ne = 2.71828\nsentence = 'e is equal to {:.2f}'.format(e)\nprint(sentence)\n</code></pre> Output<pre><code>e is equal to 2.72\n</code></pre></p> <p>By using <code>:,</code> within the placeholder, we can format a number with a thousands separator, <code>,</code>.  Input<pre><code>sentence = '1 KM is equal to {:,.2f} meters'.format(1000)\nprint(sentence)\n</code></pre> Output<pre><code>1 KM is equal to 1,000.00 meters\n</code></pre></p>"},{"location":"04_advanced_formatting/#44-formatting-date-and-time-with-datetime","title":"4.4. Formatting Date and Time with <code>datetime</code>","text":"<p>When formatting date and time, we can refer to the strftime and strptime behavior for the format codes.</p> <p>In the following code, we are using Python's <code>datetime</code> module to create a <code>datetime</code> object representing a specific date and time. We create a <code>datetime</code> object for <code>April 1, 2023, 10:10:30 AM</code>, and print it. Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\nprint(today_date)\n</code></pre> Output<pre><code>2023-04-01 10:10:30\n</code></pre></p> <p>We can use the <code>strftime</code> method to format the date in a more human-readable format. The <code>strftime</code> method allows you to create custom date and time formats by using format codes. We can use the <code>strftime</code> method to format the date. </p> <p>But we have to import the <code>datetime</code> module first. </p> <p>Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\ntoday_date = '{:%B %d, %Y}'.format(today_date)\nprint(today_date)\n</code></pre> Output<pre><code>April 01, 2023\n</code></pre> Here, we use the format codes %B, %d, and %Y to display the full month name, the day of the month with a leading zero, and the year with the century, respectively. The resulting formatted date is passed to the format function and printed.</p> <p>We can also use the <code>strptime</code> method to parse the string into a date: Input<pre><code>import datetime\ndate_str = 'April 01, 2023'\ntoday_date = datetime.datetime.strptime(date_str, '%B %d, %Y')\nprint(today_date)\n</code></pre> Output<pre><code>2023-04-01 00:00:00\n</code></pre> n this example, we have the date string <code>'April 01, 2023'. The format codes used to parse this string are</code>%B<code>,</code>%d<code>, and</code>%Y`, which represent the full month name, the day of the month with a leading zero, and the year with the century, respectively. The strptime method reads the date string and creates a datetime object with the provided date information. Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\nsentence = 'Today is {0:%B %d, %Y} on {0:%A}, and {0:%Y} has passed {0:%j} days'.format(today_date)\nprint(sentence)\n</code></pre> Output<pre><code>Today is April 01, 2023 on Thursday, and 2023 has passed 091 days\n</code></pre></p> <p>We can also use the <code>timetuple</code> method to remove the <code>0</code> in the beginning of <code>091</code>: Input<pre><code>sentence = 'Today is {0:%B %d, %Y} on {0:%A}, and {0:%Y} has passed {1:d} days'.format(today_date, today_date.timetuple().tm_yday)\nprint(sentence)\n</code></pre> Output<pre><code>Today is April 01, 2023 on Thursday, and 2023 has passed 91 days\n</code></pre></p>"},{"location":"05_loops_comprehensions/","title":"5. Loops and Comprehensions","text":""},{"location":"05_loops_comprehensions/#51-loops","title":"5.1. Loops","text":"<p>This chapter provides an overview of loops and iterations in Python, specifically focusing on the <code>for</code>, <code>while</code>, and <code>else</code> statements.</p>"},{"location":"05_loops_comprehensions/#511-for-loops","title":"5.1.1. For Loops","text":"<p>In this section, we will cover the following statements and functions:</p> <ul> <li>Basic Usage: The for loop iterates over a list of pets and prints each pet's name. This is the simplest usage of a for loop.</li> <li><code>break</code> Statement: The for loop is used in combination with a conditional statement and break, which terminates the loop once a specific condition is met. </li> <li><code>continue</code> Statement: The continue statement is used to skip the rest of the current loop iteration and immediately start the next one. </li> <li>Nested for Loops: This demonstrates the concept of nested loops, where a for loop is contained within another for loop. </li> <li><code>range()</code> Function: The <code>range()</code> function generates a sequence of numbers over which the for loop iterates. The function can be called with different numbers of arguments to change the start, end, and step size of the sequence.</li> </ul> <p>This chapter provides an excellent foundation for understanding loops in Python.</p> <p>Basic Usage</p> <p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nprint(pet)\n</code></pre> Output<pre><code>Tub\nBarkalot\nFurrytail\n</code></pre> This code creates a list of pet names, then uses a <code>for</code> loop to iterate over each item in the list. Each time through the loop, it prints the current pet name.</p> <p><code>break</code> Statement</p> <p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nif pet == 'Barkalot':\nprint('We got Barkalot!')\nbreak\nprint(pet)\n</code></pre> Output<pre><code>Tub\nWe got Barkalot!\n</code></pre> This code is similar to the previous example, but it includes an <code>if</code> statement that checks whether the current pet name is <code>Barkalot</code>. If it is, the code prints a special message and then uses the <code>break</code> statement to immediately exit the loop.</p> <p><code>continue</code> Statement</p> <p>Input<pre><code># `continue` statement skip the current iteration and continue with the next.\n# Here we skip the `Barkalot` pet and print `We got Barkalot!` instead.\npets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nif pet == 'Barkalot':\nprint('We got Barkalot!')\ncontinue\nprint(pet)\n</code></pre> Output<pre><code>Tub\nWe got Barkalot!\nFurrytail\n</code></pre></p> <p>Again, this code is similar to the previous examples. The difference is that when the current pet name is <code>Barkalot</code>, it uses the <code>continue</code> statement to immediately start the next iteration of the loop, skipping the <code>print(pet)</code> statement for <code>Barkalot</code>.</p> <p>Nested for Loops</p> <p>Input<pre><code>for pet in pets:\nfor letter in 'ab':\nprint(letter, pet)\n</code></pre> Output<pre><code>a Tub\nb Tub\na Barkalot\nb Barkalot\na Furrytail\nb Furrytail\n</code></pre> Here, the outer <code>for</code> loop iterates over the list of pet names, and the inner <code>for</code> loop iterates over the string 'ab'. For each combination of pet name and letter, it prints the letter and the pet name.</p> <p><code>range()</code> Function</p> <p>Input<pre><code>for pet in pets:\nfor num in range(2):\nprint(num, pet)\n</code></pre> Output<pre><code>0 Tub\n1 Tub\n0 Barkalot\n1 Barkalot\n0 Furrytail\n1 Furrytail\n</code></pre></p> <p>This code is the same as the previous example, but the inner loop iterates over the numbers produced by <code>range(2)</code>, which are 0 and 1.</p> <p><code>range()</code> Function with Start and End</p> <p>Input<pre><code>for num in range(0, 5):\nprint(num)\n</code></pre> Output<pre><code>0\n1\n2\n3\n4\n</code></pre></p> <p>This code uses the <code>range()</code> function to generate a sequence of numbers from 0 to 4. The <code>for</code> loop iterates over these numbers, printing each one.</p> <p><code>range()</code> Function with Start, End, and Step</p> <p>Input<pre><code>for num in range(0, 5, 2):\nprint(num)\n</code></pre> Output<pre><code>0\n2\n4\n</code></pre></p> <p>This code is similar to the previous example, but it adds a step size of 2 to the <code>range()</code> function. This means it only generates every second number in the range from 0 to 4, so the <code>for</code> loop prints the numbers 0, 2, and 4.</p>"},{"location":"05_loops_comprehensions/#512-while-loops","title":"5.1.2. While Loops","text":"<p>In Python, a <code>while</code> loop repeatedly executes a target statement as long as a given condition is true.</p> <p>For example: Input<pre><code>num = 1\nwhile num &lt; 5:\nprint(num)\nnum += 1\n</code></pre> Output<pre><code>1\n2\n3\n4\n</code></pre></p> <p>The <code>while</code> loop above continues executing until the condition <code>num &lt; 5</code> is no longer true, which occurs after the fourth iteration.</p> <p>Using <code>break</code> with While Loop</p> <p>The <code>break</code> statement is used to exit a <code>while</code> loop prematurely. When a <code>break</code> statement is encountered inside the loop, the loop is immediately terminated, and program control resumes at the next statement following the loop.</p> <p>In the following code, <code>break</code> is triggered when <code>num</code> equals 3, causing an early exit from the loop.</p> <p>Input<pre><code>num = 1\nwhile num &lt; 5:\nif num == 3:\nbreak\nprint(num)\nnum += 1\n</code></pre> Output<pre><code>1\n2\n</code></pre></p> <p><code>break</code> in an Infinite Loop</p> <p>An infinite <code>while</code> loop can be created using <code>while True:</code>. This loop will run indefinitely unless it encounters a <code>break</code> statement.</p> <p><code>break</code> is used to stop an otherwise infinite loop when num equals 3:</p> <p>Input<pre><code>num = 1\nwhile True:\nif num == 3:\nbreak\nprint(num)\nnum += 1\n</code></pre> Output<pre><code>1\n2\n</code></pre></p> <p>If Statement versus While Loop</p> <p>An <code>if</code> statement checks a condition once, whereas a <code>while</code> loop continues to execute the block of code as long as the condition is true.</p> <p>Input<pre><code>num = 1\nif num &lt; 5:\nprint(num)\nnum += 1\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>In this code, the <code>if</code> statement checks the condition <code>num &lt; 5</code> once and then executes the block of code if the condition is true. After that, it doesn't check the condition again or repeat the block of code. This is the main difference between a <code>while</code> loop and an <code>if</code> statement.</p>"},{"location":"05_loops_comprehensions/#513-else-clause-with-loops","title":"5.1.3. Else Clause with Loops","text":"<p>The <code>else</code> clause in Python can also be used with loops. Unlike in an <code>if</code> statement, where <code>else</code> executes when the <code>if</code> condition is false, with loops, the else clause executes after the loop completes normally, i.e., when no <code>break</code> statement has been encountered.</p> <p>If-Else</p> <p>The else clause executes after the loop completes normally.</p> <p>Here's a simple example of an <code>if-else</code> statement:</p> <p>Input<pre><code>tub_age = 5\nif tub_age &gt; 18:\nprint('Tub is an adult.')\nelse:\nprint('Tub is a child.')\n</code></pre> Output<pre><code>Tub is a child.\n</code></pre></p> <p>The <code>else</code> clause is executed because the <code>if</code> condition is false.</p> <p>Else with For Loop</p> <p>In the context of a <code>loop</code>, an else statement can be thought of as a \"no break\" statement. It will execute once the loop has finished iterating over the items.</p> <p>Another example may not be so obvious. And always makes people confused:</p> <p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nprint(pet)\nelse: # More like a `no break` statement\nprint('No more pets.')\n</code></pre> Output<pre><code>Tub\nBarkalot\nFurrytail\nNo more pets.\n</code></pre></p> <p>The <code>else</code> statement associated with a loop (either a <code>for</code> or <code>while</code> loop) in Python might initially seem confusing since in many other programming languages <code>else</code> is associated only with <code>if</code> statements.</p> <p>You may think why the <code>else</code> statement is executed?</p> <p>In Python, the <code>else</code> clause in a loop executes when the loop has finished iterating over all items (in a <code>for</code> loop) or when the condition becomes false (in a <code>while</code> loop), but not when the loop is prematurely ended by a <code>break</code> statement.</p> <p>Let's break down the above example:</p> <ul> <li> <p>The <code>for</code> loop begins iterating over the <code>pets</code> list. For each pet in <code>pets</code>, it prints the pet's name.</p> </li> <li> <p>When there are no more items left in the <code>pets</code> list, the loop's condition becomes false (it has run out of items to process). At this point, instead of just ending, it checks if there is an <code>else</code> clause associated with it.</p> </li> <li> <p>Since there is an <code>else</code> clause, it runs the code inside the <code>else</code> block. The print statement inside the <code>else</code> block runs, outputting <code>No more pets.</code>.</p> </li> </ul> <p>So, the phrase <code>no break</code> used in comments beside the <code>else</code> statement means that if the loop finishes its iterations normally without encountering a <code>break</code> statement (i.e., it was not forced to stop prematurely), the code inside the else block will be executed.</p> <p>This behavior is particularly useful when you use a loop to search for an item in a list or another data structure. If the item is found, you can use the <code>break</code> statement to stop the loop, and the <code>else</code> block will be ignored. If the item isn't found and the loop ends normally after checking all items, the <code>else</code> block will run, allowing you to handle the case where the item isn't found.</p> <p>To understand this, let's have a more concrete example:</p> <p>In <code>for</code> loops</p> <code>else</code> terminated by <code>break</code><code>else</code> not terminated by <code>break</code> and plays as <code>no break</code> <p>Input<pre><code>for pet in pets:\nprint(pet)\nif pet == 'Barkalot':\nbreak\nelse:\nprint('No more pets.')\n</code></pre> Output<pre><code>Tub\nBarkalot\n</code></pre> The <code>else</code> statement is not executed because the loop is terminated by the <code>break</code> statement.</p> <p>Input<pre><code>for pet in pets:\nprint(pet)\n# Now the loop is not terminated by the `break` statement\n# as the condition is never met  as the above example.\n# You can remove the `if` statement, and it will still work.\nif pet == 'NOT EXIST':\nbreak\nelse: # More like a `no break` statement.\nprint('No more pets.')\n</code></pre> Output<pre><code>Tub\nBarkalot\nFurrytail\nNo more pets.\n</code></pre></p> <p>This is also the same as for <code>while</code> loop.</p> <code>else</code> within <code>while</code> loop and terminated by <code>break</code><code>else</code> within <code>while</code> loop and plays as <code>no break</code> <p>Input<pre><code>age = 7\nwhile age &gt;=5:\nprint(age)\nage -= 1\nelse: # More like a `no break` statement\nprint('End')\n</code></pre> Output<pre><code>7\n6\n5\nEnd\n</code></pre> The <code>else</code> statement is not executed because the loop is terminated by the <code>break</code> statement.</p> <p>Input<pre><code>age = 7\nwhile age &gt;=5:\nprint(age)\nage -= 1\nif age == 6:\nbreak\nelse: # More like a `no break` statement\nprint('End')\n</code></pre> Output<pre><code>7\n6\n</code></pre></p> <p>In this exercise, you'll create a function that searches for a specific number in a list using a for <code>loop</code> and an <code>else</code> clause. The function should print a message indicating whether or not the number was found in the list.</p> <p>Exercise 1: Search Number in List</p> <p>Tasks:</p> <ol> <li> <p>Write a function <code>search_number_in_list</code> that takes two parameters: a list of numbers (<code>numbers_list</code>) and a number to search (<code>search_number</code>).</p> </li> <li> <p>Inside the function, start a <code>for</code> loop that iterates over each number in <code>numbers_list</code>.</p> </li> <li> <p>Inside the loop, use an <code>if</code> statement to check if the current number equals <code>search_number</code>. If it does, print a message like <code>Number {</code>search_number<code>} found in the list!</code>, and then use the <code>break</code> statement to immediately exit the loop.</p> </li> <li> <p>After the <code>for</code> loop, write an <code>else</code> clause that prints a message like <code>Number {search_number} not found in the list.</code>. This <code>else</code> clause should be executed if the <code>for</code> loop completes all its iterations without hitting the <code>break</code> statement.</p> </li> <li> <p>Test your function with a list of numbers and a search number of your choice.</p> </li> </ol> <p>Here's a skeleton of the function to get you started:</p> Skeleton to startedSolution Skeleton<pre><code>def search_number_in_list(numbers_list, search_number)--&gt;str:\n# Your code here\npass\n# Test the function\nnumbers = [1, 3, 5, 7, 9, 11]\nsearch_number = 7\nsearch_number_in_list(numbers, search_number)\n</code></pre> <p>Expected Ouput<pre><code>Number 7 found in the list!\n</code></pre> Or if you search for a number not in the list:</p> Expected Ouput<pre><code>Number {search_number} not found in the list.\n</code></pre> Solution<pre><code>numbers = [1, 3, 5, 7, 9, 11]\nsearch_number = 7\nfor num in numbers:\nif num == search_number:\nprint(f'Number {search_number} found in the list!')\nbreak\nelse:\nprint(f'Number {search_number} not found in the list.')\n</code></pre> <p>In this exercise, you'll modify the function <code>find_first_even</code> to return the index of the first even number found in the list. If no even number is found, the function should return <code>None</code>.</p> <p>Exercise 2: Find First Even Number Function</p> <p>Tasks:</p> <ol> <li> <p>Modify the function <code>find_first_even</code> that takes a list of numbers (<code>nums</code>) as parameter.</p> </li> <li> <p>Inside the function, start a <code>for</code> loop that iterates over number/s in <code>nums</code>.</p> </li> <li> <p>Inside the loop, use an <code>if</code> statement to check if the current number is even. If it is, return the current <code>num</code> and then use the <code>break</code> statement to immediately exit the loop.</p> </li> <li> <p>After the <code>for</code> loop, write an <code>else</code> clause that returns <code>None</code>. This <code>else</code> clause should be executed if the <code>for</code> loop iterates over all the numbers from the list without hitting the <code>break</code> statement. In other words, we didn't find any even number in the list.</p> </li> <li> <p>Test your function with a list of numbers of your choice.</p> </li> </ol> <p>Here's a skeleton of the function to get you started:</p> Skeleton to startedSolution Skeleton<pre><code>def find_first_even(nums)--&gt;str:\n# Your code here\npass\n# Test the function\nnums = [1, 3, 5, 7, 9, 11]\n# It should print `First even number is: 8`\nprint('First even number is: {}'.format(first_even))  \nnums = [1, 3, 5, 2, 9, 11]\n# It should print `First even number is: None`\nprint('First even number is: {}'.format(first_even))  \n</code></pre> Expected Ouput<pre><code>First even number is: 8\nFirst even number is: None\n</code></pre> Solution<pre><code>def find_first_even(nums)-&gt;str:\nfor num in nums:\nif num % 2 == 0:\nbreak\nelse:\nnum = 'None'\nreturn num\n</code></pre>"},{"location":"05_loops_comprehensions/#52-enumerate-function","title":"5.2. <code>enumerate()</code> function","text":"<p>The <code>enumerate</code> function is a built-in function in Python that allows you to loop over something and have an automatic counter, or index tracker. It adds a counter as the key of the enumerate object, alongside the items of the iterable, returning an enumerate object which you can convert to a list, tuple or other data structures. The function signature is as follows:</p> <p><code>enumerate(iterable, start=0)</code></p> <ul> <li><code>iterable</code>: any object that supports iteration</li> <li><code>start</code>: the index value from which the counter should start, default is 0</li> </ul>"},{"location":"05_loops_comprehensions/#521-basic-usage-of-enumerate","title":"5.2.1. Basic Usage of enumerate()","text":"<p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor i, pet in enumerate(pets):\nprint(i, pet)\n</code></pre> Output<pre><code>0 Tub\n1 Barkalot\n2 Furrytail\n</code></pre> Here, <code>enumerate(pets)</code> returns a sequence of tuples, and each tuple consists of two items: the index and the value of the corresponding item in the iterable. <code>i</code> and <code>pet</code> are tuple unpacking the result returned by enumerate.</p>"},{"location":"05_loops_comprehensions/#522-using-enumerate-with-a-different-start-index","title":"5.2.2. Using enumerate with a Different Start Index","text":"<p>In this example, the index starts at <code>1</code> (instead of the default 0) because we've set <code>start=1</code>.</p> <p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor i, pet in enumerate(pets, start=1):\nprint(i, pet)\n</code></pre> Output<pre><code>1 Tub\n2 Barkalot\n3 Furrytail\n</code></pre></p>"},{"location":"05_loops_comprehensions/#523-practical-usage-of-enumerate","title":"5.2.3. Practical Usage of enumerate","text":"<p><code>enumerate</code> is particularly useful when you need to track the index of items within a loop. For example, if you want to replace an item in a list:</p> <p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor i, pet in enumerate(pets):\nif pet == 'Tub':\npets[i] = 'Cat'\nprint(pets)\n</code></pre> Output<pre><code>['Cat', 'Barkalot', 'Furrytail']\n</code></pre> In the above code, we use <code>enumerate</code> to get the index of each pet. When we find the pet <code>Tub</code>, we use the index to replace <code>Tub</code> with <code>Cat</code> in the original list.</p> <p>Now it's time to try using <code>enumerate</code> in your own code! Try to think of situations where you need both the item and its index within a loop. </p> <p>Exercise: Find First Even Number and Its Index</p> <p>Tasks:</p> <ol> <li> <p>Modify the function <code>find_first_even</code> that takes a list of numbers (<code>nums</code>) as parameter.</p> </li> <li> <p>Inside the function, start a <code>for</code> loop that iterates over each number in <code>nums</code>. You'll need to use the <code>enumerate</code> function so that you have access to the index of each number.</p> </li> <li> <p>Inside the loop, use an <code>if</code> statement to check if the current number is even. If it is, return the current index and number as a <code>tuple(index, number)</code>, and then use the <code>break</code> statement to immediately exit the loop.</p> </li> <li> <p>After the <code>for</code> loop, write an <code>else</code> clause that returns <code>(None, None)</code>. This <code>else</code> clause should be executed if the <code>for</code> loop completes all its iterations without hitting the <code>break</code> statement.</p> </li> <li> <p>Test your function with a list of numbers of your choice.</p> </li> </ol> <p>Here's a skeleton of the function to get you started:</p> Skeleton to startedSolution Skeleton<pre><code>def find_first_even(nums)-&gt;tuple(int, int):\n# Your code here\nreturn (i, num)\nnums = [1, 3, 8, 7, 3, 2, 3]\nfirst_even = find_first_even(nums)\nprint('The index and value of the first even number are: {}'.format(first_even))\n# Output: The index and value of the first even number are: (2, 8)\nnums = [1, 3, 1, 7, 3, 9, 3]\nfirst_even = find_first_even(nums)\nprint('The index and value of the first even number are: {}'.format(first_even))\n# Output: The index and value of the first even number are: ('None', 'None')\n</code></pre> Expected Ouput<pre><code>The index and value of the first even number are: (2, 8)\nThe index and value of the first even number are: ('None', 'None')\n</code></pre> Solution<pre><code>def find_first_even(nums)-&gt;tuple(int, int):\nfor i, num in enumerate(nums):\nif num % 2 == 0:\nbreak\nelse:\nreturn ('None', 'None')\nreturn (i, num)\n</code></pre>"},{"location":"05_loops_comprehensions/#53-list-comprehensions","title":"5.3. List Comprehensions","text":"<p>List comprehensions are a powerful feature in Python, allowing you to create lists from existing lists or other iterable objects. They provide a concise way to apply operations to the values in a sequence.</p>"},{"location":"05_loops_comprehensions/#531-basic-list-comprehensions","title":"5.3.1. Basic List Comprehensions","text":"<p>Consider the following example where we have a list of ages, and we want to create a new list with the same ages:</p> <p>Using For loop</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nage_list = []\nfor age in ages:\nage_list.append(age)\nprint(age_list)\n</code></pre> Output<pre><code>[5, 12, 3, 56, 24, 78, 1, 15, 44]\n</code></pre></p> <p>Now, we make the above for loop into a list comprehension</p> <p>Input<pre><code># [item for item in iterable]\nage_list = [age for age in ages]\nprint(age_list)\n</code></pre> Output<pre><code>[5, 12, 3, 56, 24, 78, 1, 15, 44]\n</code></pre></p> <p>Another example, we also apply operations to the values in the sequence. For example, we can add 1 to each age:</p> <p>Using For loop</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nage_list = []\nfor age in ages:\nage_list.append(age + 1)\nprint(age_list)\n</code></pre> Output<pre><code>[6, 13, 4, 57, 25, 79, 2, 16, 45]\n</code></pre></p> <p>List comprehension</p> <p>Input<pre><code># [expression for item in iterable]\nage_list = [age + 1 for age in ages]\nprint(age_list)\n</code></pre> Output<pre><code>[6, 13, 4, 57, 25, 79, 2, 16, 45]\n</code></pre></p>"},{"location":"05_loops_comprehensions/#532-comparing-list-comprehensions-and-map","title":"5.3.2. Comparing List Comprehensions and <code>map</code>","text":"<p><code>map()</code> is a built-in function that applies a function to each item in an iterable object. It returns a map object, which can be converted into a list or tuple. </p> <p>Let's see how we can use <code>map</code> to add 1 to each age as the previous example:</p> <p>Input<pre><code>age_list = list(map(lambda age: age + 1, ages))\nprint(age_list)\n</code></pre> Output<pre><code>[6, 13, 4, 57, 25, 79, 2, 16, 45]\n</code></pre></p> <p><code>map</code> is faster than list comprehension, but list comprehension is more readable.</p>"},{"location":"05_loops_comprehensions/#533-list-comprehensions-with-conditionals","title":"5.3.3. List Comprehensions with Conditionals","text":"<p>You can also include conditions in your list comprehension. For example, we can create a list that only contains even ages:</p> <p>Using For loop</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nage_list = []\nfor age in ages:\nif age % 2 == 0:\nage_list.append(age)\nprint(age_list)\n</code></pre> Output<pre><code>[12, 56, 24, 78, 44]\n</code></pre></p> <p>List comprehension</p> <p>Input<pre><code># [expression for item in iterable if condition]\nage_list = [age for age in ages if age % 2 == 0]\nprint(age_list)\n</code></pre> Output<pre><code>[12, 56, 24, 78, 44]\n</code></pre></p> <p>Using <code>lambda</code> with <code>filter</code></p> <p>Input<pre><code># filter(lambda)\nage_list = list(filter(lambda age: age % 2 == 0, ages))\nprint(age_list)\n</code></pre> Output<pre><code>[12, 56, 24, 78, 44]\n</code></pre></p>"},{"location":"05_loops_comprehensions/#534-real-world-example","title":"5.3.4. Real World Example","text":"<p>List comprehensions can be used to solve real-world problems more concisely. For example, let's say you want to create an unordered HTML list from a list of pet names:</p> <p>Using For loop</p> <p>Input<pre><code>pets = ['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Bumblefluff ', 'Whiskerfloof']\noutput = '&lt;ul&gt;\\n'\nfor pet in pets:\noutput += '\\t&lt;li&gt;{}&lt;/li&gt;\\n'.format(pet)\n# print('Address of output is {}'.format(id(output)))\noutput += '&lt;/ul&gt;'\nprint(output)\n</code></pre> Output<pre><code>&lt;ul&gt;\n&lt;li&gt;Tub&lt;/li&gt;\n&lt;li&gt;Furrytail&lt;/li&gt;\n&lt;li&gt;Cat&lt;/li&gt;\n&lt;li&gt;Barkalot&lt;/li&gt;\n&lt;li&gt;Bumblefluff &lt;/li&gt;\n&lt;li&gt;Whiskerfloof&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <ul> <li>Tub</li> <li>Furrytail</li> <li>Cat</li> <li>Barkalot</li> <li>Bumblefluff</li> <li>Whiskerfloof</li> </ul> <p>List comprehension</p> <p>Input<pre><code>pets = ['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Bumblefluff ', 'Whiskerfloof']\noutput = '&lt;ul&gt;\\n'\n# List comprehension to create a list of formatted list items\nformatted_pet_names = ['\\t&lt;li&gt;{}&lt;/li&gt;'.format(pet) for pet in pets]\n# Join the list items with newline characters and add the closing &lt;/ul&gt; tag\noutput += '\\n'.join(formatted_pet_names) + '\\n&lt;/ul&gt;'\nprint(output)\n</code></pre> Output<pre><code>&lt;ul&gt;\n&lt;li&gt;Tub&lt;/li&gt;\n&lt;li&gt;Furrytail&lt;/li&gt;\n&lt;li&gt;Cat&lt;/li&gt;\n&lt;li&gt;Barkalot&lt;/li&gt;\n&lt;li&gt;Bumblefluff &lt;/li&gt;\n&lt;li&gt;Whiskerfloof&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p>"},{"location":"05_loops_comprehensions/#535-performance-comparison-for-loop-vs-list-comprehension","title":"5.3.5. Performance Comparison: For Loop vs List Comprehension","text":"<p>Let's compare the performance of using a <code>for</code> loop vs a list comprehension to generate a list of formatted numbers:</p> <p>Input<pre><code>import timeit\nimport random\n# Create a list of 10,000 random numbers between 0 and 100\nnums = [random.randint(0, 100) for i in range(10000)]\n# For loop implementation\ndef for_loop():\noutput = '&lt;ul&gt;\\n'\nfor num in nums:\noutput += '\\t&lt;li&gt;{}&lt;/li&gt;\\n'.format(num)\noutput += '&lt;/ul&gt;'\nreturn output\n# List comprehension implementation\ndef list_comprehension():\noutput = '&lt;ul&gt;\\n' + ''.join(['\\t&lt;li&gt;{}&lt;/li&gt;\\n'.format(num) for num in nums]) + '&lt;/ul&gt;'\nreturn output\n# Measure the execution time of both implementations\nfor_loop_time = timeit.timeit(for_loop, number=1000)\nlist_comprehension_time = timeit.timeit(list_comprehension, number=1000)\nprint(\"For loop execution time: \", for_loop_time)\nprint(\"List comprehension execution time: \", list_comprehension_time)\n</code></pre> Output<pre><code>For loop execution time:  0.01699999999999999\nList comprehension execution time:  0.012999999999999956\n</code></pre></p> <p>When running this code, you'll find that the list comprehension implementation is typically faster than the <code>for</code> loop implementation. This is because list comprehensions are optimized for performance in Python, and they can often perform the same task more quickly than the equivalent <code>for</code> loop. However, the difference in speed may not be significant unless you're dealing with very large data sets.</p> <p>It's also worth noting that while list comprehensions can be faster and more concise, they can also be harder to read if they become too complex. Therefore, it's important to strike a balance between performance and readability when writing your code.</p> Pros of List Comprehensions vs For LoopsCons of List Comprehensions Vs For Loops <ul> <li> <p>Succinctness: List comprehensions provide a concise way to create lists. They can often achieve the same result as a for-loop in a single, short line of code.</p> </li> <li> <p>Speed: List comprehensions are generally faster than for-loops because they are specifically optimized for creating new lists.</p> </li> <li> <p>Functionality: List comprehensions can incorporate conditionals and multiple for-loops, enabling quite complex list creation in a single line.</p> </li> </ul> <ul> <li> <p>Readability: List comprehensions can be harder to read than for-loops, especially if they are complex.</p> </li> <li> <p>MemoryUsage: List comprehensions create new lists in memory, which can cause problems if you're working with very large data sets.</p> </li> <li> <p>Debugging: List comprehensions can be harder to debug than for-loops, especially if they are complex.</p> </li> </ul>"},{"location":"05_loops_comprehensions/#54-zip-function","title":"5.4. zip() Function","text":"<p>In Python, the <code>zip()</code> function is used to combine corresponding elements from multiple iterables (like lists or tuples) into tuples. Let's first understand it with an example:</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nnames = ['Tub', 'Barkalot', 'Furrytail']\nprint(zip(ages, names))\nprint(list(zip(ages, names)))\n</code></pre> Output<pre><code>&lt;zip object at 0x0000020F6F6F0A48&gt;\n[(5, 'Tub'), (12, 'Barkalot'), (3, 'Furrytail')]\n</code></pre> What zip does is it takes the first item from each iterable and puts them together in a tuple then it takes the second item from each iterable and puts them together in a tuple and so on. The result is a zip object that we can convert into a list of tuples using the <code>list()</code> function.</p>"},{"location":"05_loops_comprehensions/#541-zip-with-for-loop","title":"5.4.1. zip() with for Loop","text":"<p>In the following example, the <code>zip()</code> function pairs up the elements from ages and names lists by their indices.</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nnames = ['Tub', 'Barkalot', 'Furrytail']\nmy_list = []\nfor age in range(3):\nfor name in names:\nmy_list.append((age, name))\nprint(my_list)\n</code></pre> Output<pre><code>[(0, 'Tub'), (0, 'Barkalot'), (0, 'Furrytail'), (1, 'Tub'), (1, 'Barkalot'), (1, 'Furrytail'), (2, 'Tub'), (2, 'Barkalot'), (2, 'Furrytail')]\n</code></pre> We can utilize this function along with comprehensions for more complex operations.</p>"},{"location":"05_loops_comprehensions/#542-zip-with-list-comprehension","title":"5.4.2. zip() with List Comprehension","text":"<p>Similarly, we can use<code>zip()</code> with list comprehensions. Let's create a list of tuples where each tuple consists of a number and a pet name:</p> <p>Input<pre><code>my_list = [(age, name) for age in range(3) for name in names]\nprint(my_list)\n</code></pre> Output<pre><code>[(0, 'Tub'), (0, 'Barkalot'), (0, 'Furrytail'), (1, 'Tub'), \n(1, 'Barkalot'), (1, 'Furrytail'), (2, 'Tub'), (2, 'Barkalot'), (2, 'Furrytail')]\n</code></pre></p> <p>This code creates a tuple for each combination of age and name, and adds it to the list. Here, <code>age</code> ranges from <code>0</code> to <code>2</code>, and <code>name</code> is taken from the <code>names</code> list.</p>"},{"location":"05_loops_comprehensions/#55-dictionary-comprehensions","title":"5.5. Dictionary Comprehensions","text":"<p>A dictionary comprehension is similar to a list comprehension, but it constructs a dictionary instead of a list.</p> <p>If we want to create a dictionary that maps each pet's name to its age, we can use a for-loop like this:</p> <p>Regular For Loop with zip()</p> <p>Input<pre><code>my_dict = {}\nfor age, name in zip(ages, names):\nmy_dict[name] = age\nprint(my_dict)\n</code></pre> Output<pre><code>{'Tub': 5, 'Barkalot': 12, 'Furrytail': 3}\n</code></pre></p> <p>Dictionary comprehension with zip()</p> <p>Input<pre><code># {key: value for item in iterable}\nmy_dict = {name: age for name, age in zip(names, ages)}\nprint(my_dict)\n</code></pre> Output<pre><code>{'Tub': 5, 'Barkalot': 12, 'Furrytail': 3}\n</code></pre> Here, <code>name</code>: <code>age</code> is the key-value pair for each item in the dictionary.</p> <p>We can also add a condition in the dictionary comprehension to filter the items:</p> <p>Input<pre><code># {key: value for item in iterable if condition}\nmy_dict = {name: age for name, age in zip(names, ages) if age &gt; 10}\nprint(my_dict)\n</code></pre> Output<pre><code>{'Barkalot': 12}\n</code></pre></p> <p>This will include only the pets that are older than 10 in the dictionary.</p>"},{"location":"05_loops_comprehensions/#56-set-comprehensions","title":"5.6. Set Comprehensions","text":"<p>Set comprehensions work just like list and dictionary comprehensions, but they produce a set, which is an unordered collection of unique elements.</p> <p>Let's start with an example where we want to create a set from the ages list:</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\nnames = ['Tub', 'Barkalot', 'Furrytail']\nmy_set = set()\nfor age in ages:\nmy_set.add(age)\nprint(my_set)\n</code></pre> Output<pre><code>{1, 3, 5, 12, 15, 44, 56, 78}\n</code></pre></p> <p>We're creating a set and adding each age to it. The resulting set includes each age once, even if it appeared multiple times in the list.</p> <p>We can achieve the same result more succinctly with a set comprehension:</p> <p>Input<pre><code># {expression for item in iterable}\nmy_set = {age for age in ages}\nprint(my_set)\n</code></pre> Output<pre><code>{1, 3, 5, 12, 15, 44, 56, 78}\n</code></pre></p> <p>Here, <code>age for age in ages</code> is the expression for each item in the set.</p> <p>Similar to list and dictionary comprehensions, we can also include a condition in the set comprehension:</p> <p>Input<pre><code># {expression for item in iterable if condition}\nmy_set = {age for age in ages if age &gt; 10}\nprint(my_set)\n</code></pre> Output<pre><code>{12, 15, 44, 56, 78}\n</code></pre></p> <p>This will include only the ages that are greater than <code>10</code> in the set.</p> <p>In summary, set comprehensions provide a concise way to create sets in Python. They can be especially useful when you need to remove duplicates from a list or other iterable, because sets automatically discard duplicate values.</p>"},{"location":"05_loops_comprehensions/#56-generator-compreshensions","title":"5.6. Generator Compreshensions","text":"<p>Generator comprehensions are an elegant way to create generators using a syntax that is similar to list comprehensions. In fact, you can convert a list comprehension into a generator comprehension just by replacing the square brackets <code>[]</code> with parentheses <code>()</code>.</p> <p>Generators are a powerful feature in Python for creating iterable objects. They are a key component of Python's approach to handling large data streams or sequences of data because they enable you to create an iterable object without needing to store all of the values in memory at once. This can provide substantial performance benefits when dealing with large data sets.</p> <p>We will cover more details in the next Chapter. </p>"},{"location":"05_loops_comprehensions/#561-traditional-generator-function","title":"5.6.1. Traditional Generator Function","text":"<p>The gen_func function is a generator function that takes a list of ages as an argument. Inside this function, we iterate over the ages list using a for loop. For each age in ages, we yield the value of age incremented by 1. The yield keyword is used in Python generator functions as a sort of \"return\" that does not end the function, but instead provides a value and pauses the function's execution until the next value is requested.</p> <p>Input<pre><code>ages = [5, 12, 3, 56, 24, 78, 1, 15, 44]\ndef gen_func(ages):\nfor age in ages:\nyield age+1\nmy_gen = gen_func(ages)\nfor item in my_gen:\nprint(item)\n</code></pre> Output<pre><code>6\n13\n4\n57\n25\n79\n2\n16\n45\n</code></pre></p> <p>The <code>gen_func</code> function is a generator function that takes a list of <code>ages</code> as an argument. Inside this function, we iterate over the <code>ages</code> list using a <code>for</code> loop. For each <code>age</code> in <code>ages</code>, we <code>yield</code> the value of <code>age</code> incremented by 1. The <code>yield</code> keyword is used in Python generator functions as a sort of \"return\" that does not end the function, but instead provides a value and pauses the function's execution until the next value is requested.</p> <p>We call our generator function <code>gen_func</code> with the <code>ages</code> list as the argument, and the result (a generator object) is assigned to <code>my_gen</code>. Then we use a <code>for</code> loop to iterate over the generator object, which causes the generator function to execute and <code>yield</code> its values one by one. Each yielded value is printed out.</p>"},{"location":"05_loops_comprehensions/#562-generator-comprehension","title":"5.6.2. Generator Comprehension","text":"<p>The second part of the code shows a generator comprehension, which is a more compact way of creating a generator. The syntax is very similar to list comprehensions, but uses parentheses <code>()</code> instead of square brackets <code>[]</code>.</p> <p>Input<pre><code># (expression for item in iterable)\nmy_gen = (age for age in ages)\nprint(my_gen)\nfor item in my_gen:\nprint(item)\n</code></pre> Output<pre><code>&lt;generator object &lt;genexpr&gt; at 0x0000020F6F6F0A48&gt;\n5\n12\n3\n...\n</code></pre></p> <p>This line creates a generator object that will generate the same values as the <code>ages</code> list, but on-demand, not storing the entire list in memory.</p> <p>Generators, both through traditional functions and comprehensions, are a powerful tool in Python. They provide an efficient way to work with large data sets or streams of data that would be inefficient or impractical to store in memory all at once.</p>"},{"location":"06_iterable_iterator_generator/","title":"6. Iterable, Iterator, Generator","text":"<p>In Python, Iterables and Iterators might seem similar, but they serve distinct purposes and have unique characteristics.</p> <p>An Iterable is an object that can be looped over. This means you can go through its elements one by one, typically using a for loop. Lists, tuples, strings, and dictionaries are all examples of Iterables. They need to implement an <code>__iter__()</code> method that returns an Iterator or a <code>__getitem__()</code> method for indexed access.</p> <p>An Iterator, on the other hand, is an object that keeps track of its current state during iteration. It must have a <code>__next__()</code> method, which returns the next item in the sequence and moves forward, and an <code>__iter__()</code> method that returns self. One key aspect of Iterators is that they can only move forward; you can't get an item that has already been iterated over unless you create a new Iterator.</p> <p>So, the primary difference is that while both can be iterated over, an Iterator also keeps track of its current position in the Iterable. While all Iterators are Iterables (because they implement an <code>__iter__()</code> method), not all Iterables are Iterators (because they do not provide a <code>__next__()</code> method). The power of Iterators comes from their ability to provide items one at a time rather than storing all items in memory at once, which is especially useful when working with large data sets.</p> <p>A generator is a specific type of iterator, which allows us to implement an iterator in a clear and concise way. It's a special kind of function that returns an iterator which we can iterate over to yield sequence of values.</p> <p>The main difference between a function and a generator in Python is the presence of the yield keyword. While a return statement completely finishes a function execution, yield produces a value and suspends the function\u2019s execution. The function can then be resumed from where it left off, allowing the function to produce a series of values over time, rather than computing them all at once and sending them back.</p>"},{"location":"06_iterable_iterator_generator/#61-iterable","title":"6.1. Iterable","text":"<p>Data types are Iterables in Python:</p> <ul> <li>Lists</li> <li>Tuples</li> <li>Strings</li> <li>Dictionaries</li> <li>Sets</li> <li>Generators</li> </ul> <p>In Python, an Iterable is an object that can be iterated (looped) over. Essentially, if an object has an <code>__iter__()</code> method, it is an Iterable.</p> <p>You can use <code>dir()</code> to check if an object is iterable</p> <p>Here's an example:</p> <p>Input<pre><code>pets = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nfor pet in pets:\nprint(pet)\n</code></pre> Output<pre><code>Tub\nFurrytail\nCat\nBarkalot\n</code></pre></p> <p>In this case, <code>pets</code> is a list, and lists in Python are Iterables. We can loop over the list using a <code>for</code> loop, and it will print each pet's name one at a time.</p>"},{"location":"06_iterable_iterator_generator/#611-checking-if-an-object-is-iterable","title":"6.1.1. Checking if an Object is Iterable","text":"<p>You can check whether an object is iterable by using Python's built-in <code>dir()</code> function. If <code>__iter__</code> appears in the output, the object is iterable.</p> <p>Input<pre><code>print('__iter__' in dir(pets))  # Will output: True\n</code></pre> Output<pre><code>True\n</code></pre></p>"},{"location":"06_iterable_iterator_generator/#62-iterator","title":"6.2. Iterator","text":"<p>An Iterator, on the other hand, is an object with a state that remembers where it is during iteration. While all Iterator objects are Iterable, not all Iterables are Iterators.</p> <p>An Iterator object is initialized using the <code>iter()</code> method, and the <code>next()</code> method is used for iteration. Important to note, an Iterator can only move forward; it cannot go backward.</p> <p>Let's turn our list of pets into an Iterator:</p> <p>Input<pre><code>pets = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(next(pets))\n</code></pre> Output<pre><code>Output: TypeError: 'list' object is not an iterator\n</code></pre> Here we get an error because <code>pets</code> is a list, and lists are not Iterators. We can, however, turn it into an Iterator using the <code>iter()</code> method:</p> <p>Input<pre><code>iterator_obj = pets.__iter__()\nprint(iterator_obj)\n</code></pre> Output<pre><code>&lt;list_iterator object at 0x000001E0F9F4B4C0&gt;\n</code></pre></p> <p>Or a better way to do it is: Input<pre><code>iterator_obj = iter(pets)\nprint(iterator_obj)\n</code></pre> Output<pre><code>&lt;list_iterator object at 0x000001E0F9F4B4C0&gt;\n</code></pre> Now, <code>iterator_obj</code> is an Iterator. You can't use <code>next()</code> directly on the list pets (you would get a <code>TypeError</code>), but you can on <code>iterator_obj</code>. Let's print the names one by one:</p> <p>Input<pre><code>print(next(iterator_obj))\nprint(next(iterator_obj))\nprint(next(iterator_obj))\nprint(next(iterator_obj))\nprint(next(iterator_obj)) # This will raise StopIteration error\n</code></pre> Output<pre><code>Tub\nFurrytail\nCat\nBarkalot\nStopIteration\n</code></pre> Calling <code>next()</code> again would result in a StopIteration error, as there are no more items to iterate over. This is how Python signals the end of an Iterator.</p>"},{"location":"06_iterable_iterator_generator/#621-handling-stopiteration","title":"6.2.1. Handling StopIteration","text":"<p>We can handle the <code>StopIteration</code> error elegantly using a try/except block. Here's how to loop over all the elements of an Iterator, stopping cleanly when there are no more items:</p> <p>Input<pre><code>pets = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\niterator_obj = iter(pets)\nwhile True:\ntry:\nnext_obj = next(iterator_obj)\nprint(next_obj)\nexcept StopIteration:\nbreak\n</code></pre> Output<pre><code>Tub\nFurrytail\nCat\nBarkalot\n</code></pre></p> <p>This will print out each pet's name, just like the <code>for</code> loop did earlier, but this time we're using the Iterator's <code>next()</code> method.</p> <p>When we reach the end of the Iterator and a <code>StopIteration</code> exception is thrown, our <code>except</code> clause catches it and we <code>break</code> out of the loop, preventing any errors.</p> <p>NOTE: Here is one example of how to create a Iterator class, we will cover more details in Chapter 7</p> <p>Creating a Custom Iterator</p> <p>Let's look at an example: the <code>NumIter</code> class, which is a simple iterator that counts numbers within a given range. Input<pre><code>class NumIter:\ndef __init__(self, start, end):\nself.start = start\nself.end = end\nself.current = start\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.current &gt;= self.end:\nraise StopIteration\nelse:\nreturn_val = self.current\nself.current += 1\nreturn return_val\n</code></pre> Here's what's happening in this code:</p> <ol> <li> <p>The <code>__init__</code> method initializes the iterator. It takes a <code>start</code> and an <code>end</code> as arguments, which determine the range of numbers that the iterator will cover. self.current is used to keep track of the current number in the sequence.</p> </li> <li> <p>The <code>__iter__</code> method is what makes this class an Iterable. It returns <code>self</code>, indicating that an instance of the class is its own iterator.</p> </li> <li> <p>The <code>__next__</code> method is the heart of an Iterator. It returns the next value in the sequence each time it's called, and increments <code>self.current</code> to prepare for the next call. When there are no more numbers left in the sequence, it raises the <code>StopIteration</code> exception, signalling that all values have been returned.</p> </li> </ol> <p>Now, let's see how we can use this NumIter class:</p> <p>Input<pre><code>nums = NumIter(1, 5)\nfor num in nums:\nprint(num)\n</code></pre> Output<pre><code>1\n2\n3\n4\n</code></pre> In this code, we create an instance of <code>1</code> that starts at <code>1</code> and ends at <code>5</code>. We then use a <code>1</code> loop to iterate over <code>1</code>. This will output the numbers <code>1</code> to <code>4</code>, one per line.</p> <p>Note that after you've iterated over an Iterator, it's \"<code>exhausted</code>\" and you can't iterate over it again. So if you try to use the <code>1</code> loop with 1 again, it won't print anything.</p> <p>However, if we create a new instance, we can manually iterate over it using the <code>next()</code> function: Input<pre><code>nums = NumIter(1, 5)\nprint(next(nums))\nprint(next(nums))\nprint(next(nums))\nprint(next(nums))\nprint(next(nums))\n</code></pre> Output<pre><code>1\n2\n3\n4\nStopIteration\n</code></pre> This allows us to manually control when we want the next value, but remember that if you try to get the next value after the iterator is exhausted, it will raise a StopIteration exception.</p>"},{"location":"06_iterable_iterator_generator/#63-generator","title":"6.3. Generator","text":"<p>A generator is a special type of iterator in Python. Generators don't store all their values in memory, but generate them on the fly. This makes them more memory efficient, especially when dealing with large data sets. It doesn't need iter() and next() methods</p>"},{"location":"06_iterable_iterator_generator/#631-creating-a-generator","title":"6.3.1. Creating a Generator","text":"<p>A generator function looks very much like a regular function, but instead of returning a value, it yields it. Here's an example:</p> <p>Input<pre><code>def iter_nums(start, end):\ncurrent = start\nwhile current &lt; end:\nyield current\ncurrent +=1\n</code></pre> In this example, <code>iter_nums</code> is a generator function. It takes a <code>start</code> and an <code>end</code> argument and yields numbers from <code>start</code> up to, but not including, <code>end</code>. We can iterate over this generator using the <code>next()</code> function:</p> Input<pre><code>nums = iter_nums(1, 5)\nprint(next(nums))\nprint(next(nums))\nprint(next(nums))\n</code></pre> Output<pre><code>1\n2\n3\n</code></pre> <p>Or we can use a <code>for</code> loop:</p> <p>Input<pre><code>nums = iter_nums(1, 5)\nfor num in nums:\nprint(num)\n</code></pre> output<pre><code>1\n2\n3\n4\n</code></pre> This will output numbers 1 through 4.</p> <p>Generator function is more readable than iterator class we created previously.</p> <p>Another example</p> <p>Input<pre><code>numbers = [1, 2, 3, 4, 5]\n# Now we have a list of numbers, and we want to double each number in the list\ndef double_nums(nums):\noutput = []\nfor num in nums:\noutput.append(num*2)\nreturn output\noutput_nums = double_nums(numbers)\nprint(output_nums)\n</code></pre> Output<pre><code>[2, 4, 6, 8, 10]\n</code></pre> We can easily turn this function into a generator by replacing the append and return statements with a yield statement:</p> <p>Input<pre><code>numbers = [1, 2, 3, 4, 5]\ndef double_nums(nums):\nfor num in nums:\nyield num*2\noutput_nums = double_nums(numbers)\nprint(output_nums)\n</code></pre> As the generator doesn't store the values in memory You will get the generator object: Output<pre><code>&lt;generator object double_nums at 0x000001E0F9F4B040&gt;\n</code></pre></p> <p>To get the values, you can use <code>next()</code>: Input<pre><code>print(next(output_nums))\n</code></pre> Output<pre><code>2\n</code></pre></p> <p>Or output as a list:</p> <p>Input<pre><code>print(list(output_nums))\n</code></pre> Output<pre><code>[2, 4, 6, 8, 10]\n</code></pre></p> <p>Of course you can also convert it to the list comprehension as we mentioned in the Chapter 5:</p> <p>Input<pre><code>numbers = [1, 2, 3, 4, 5]\noutput_nums_list = [num*2 for num in numbers]\nprint(output_nums_list)\n</code></pre> Output<pre><code>[2, 4, 6, 8, 10]\n</code></pre></p>"},{"location":"06_iterable_iterator_generator/#632-generator-expressions","title":"6.3.2. Generator Expressions","text":"<p>If you replace the square brackets with the parentheses, you will get the generator object: Input<pre><code>output_nums_generator = (num*2 for num in numbers)\nprint(list(output_nums_generator))\n</code></pre> Output<pre><code>[2, 4, 6, 8, 10]\n</code></pre> In this case, <code>(num * 2 for num in numbers)</code> is a generator expression that generates doubled numbers.</p>"},{"location":"06_iterable_iterator_generator/#633-generator-vs-iterator","title":"6.3.3. Generator vs Iterator","text":"<p>In Python, both iterator and generator can be used to iterate over a sentence, word by word. They provide a convenient way to process each word individually. Let's see how we can create an iterator and a generator to do this.</p>"},{"location":"06_iterable_iterator_generator/#creating-a-sentence-iterator","title":"Creating a Sentence Iterator","text":"<p>First, let's create an iterator. The iterator class, SentIter, will split the sentence into words and yield each word one by one:</p> <p>Input<pre><code>class SentIter:\ndef __init__(self, sentence):\nself.sentence = sentence\nself.index = 0\nself.words = sentence.split()\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index &gt;= len(self.words):\nraise StopIteration\nelse:\nreturn_val = self.words[self.index]\nself.index += 1\nreturn return_val\n</code></pre> Here's how to use this iterator:</p> <p>Input<pre><code>corpus = \"Tub likes Blue Cheese\"\nwords = SentIter(corpus)\nfor word in words:\nprint(word)\n</code></pre> Output<pre><code>Tub\nlikes\nBlue\nCheese\n</code></pre> This code will output each word of the sentence on a new line.</p>"},{"location":"06_iterable_iterator_generator/#creating-a-sentence-generator","title":"Creating a Sentence Generator","text":"<p>Now, let's see how we can do the same thing with a generator. We'll write a function, <code>iter_sent</code>, that takes a sentence, splits it into words, and yields each word:</p> <p>Input<pre><code>def iter_sent(sentence):\nfor word in sentence.split():\nyield word\n</code></pre> And here's how to use this generator: Input<pre><code>words = iter_sent(corpus)\nfor word in words:\nprint(word)\n</code></pre> Output<pre><code>Tub\nlikes\nBlue\nCheese\n</code></pre> As you can see, the generator function is shorter and simpler than the iterator class. This is one of the reasons why generators are often preferred over iterators in Python.</p>"},{"location":"06_iterable_iterator_generator/#634-generator-performance","title":"6.3.4. Generator Performance","text":"<p>In Python, a generator is a simpler and more memory-efficient alternative to a list, especially when the list is large. To demonstrate the difference, let's compare the memory usage and execution time of a list and a generator.</p> <p>Firstly, let's import the necessary modules. We'll use <code>random</code> for generating random data, <code>time</code> for measuring execution time, <code>psutil</code> and <code>os</code> for measuring memory usage:</p> <p>Installation of psutil via <code>conda</code>: <pre><code>conda install -c conda-forge psutil\n</code></pre></p> <p>Performance Comparison: List vs Generator in Python</p> <p>I adapte the code with minor updates from Corey to compare the performance of list and generator Dependencies<pre><code>import random\nimport time\nimport psutil\nimport os\nimport sys\n</code></pre> Then, let's define a function to measure the current memory usage:</p> <p>Input<pre><code>def memory_usage_psutil():\nprocess = psutil.Process(os.getpid())\nmem = process.memory_info().rss / float(2 ** 20)\nreturn mem\n</code></pre> Next, let's prepare some dummy data for our test:</p> Dummy Data<pre><code>names = ['John', 'Corey', 'Adam', 'Steve', 'Rick', 'Thomas']\nmajors = ['Math', 'Engineering', 'CompSci', 'Arts', 'Business']\n</code></pre> <p>Before generating the data, we'll check and print the memory usage:</p> <p>Memory Usage (Before)<pre><code>print('Memory (Before): {}Mb'.format(memory_usage_psutil()))\n</code></pre> Now let's define a function to generate a list of people: Functions for List<pre><code>def people_list(num_people):\nresult = []\nfor i in range(num_people):\nperson = {\n'id': i,\n'name': random.choice(names),\n'major': random.choice(majors)\n}\nresult.append(person)\nreturn result\n</code></pre> And a function to generate the same data as a generator: Function for Generator<pre><code>def people_generator(num_people):\nfor i in range(num_people):\nperson = {\n'id': i,\n'name': random.choice(names),\n'major': random.choice(majors)\n}\nyield person\n</code></pre> Now let's measure the memory usage and execution time of generating the data using the list and the generator:</p> <p>List - Memory Usage<pre><code># Use people_list for comparison\nt1 = time.process_time()\npeople = people_list(1000000)\nt2 = time.process_time()\n\nprint('Memory (After) : {}Mb'.format(memory_usage_psutil()))\nprint('Took {} Seconds'.format(t2-t1))\n</code></pre> Output<pre><code>Memory (Before): 41.6484375Mb\nMemory (After) : 265.08984375Mb\nTook 0.59375 Seconds\n</code></pre> You can see the memory usage increased by <code>223.44140625Mb</code> after generating the list of people. Now let's see how the generator performs:</p> <p>Generator - Memory Usage<pre><code># Use people_generator for comparison\nt1 = time.process_time()\npeople = people_generator(1000000)\nt2 = time.process_time()\nprint('Memory (After) : {}Mb'.format(memory_usage_psutil()))\nprint('Took {} Seconds'.format(t2-t1))\n</code></pre> Output<pre><code>Memory (Before): 41.60546875Mb\nMemory (After) : 41.61328125Mb\nTook 0.0 Seconds\n</code></pre> As you can see, the memory usage increased by only <code>0.0078125Mb</code> after generating the generator object. This is because the generator doesn't store the data in memory. Instead, it yields each person one by one. This is why the memory usage of the generator is much lower than that of the list.</p>"},{"location":"07_oop/","title":"7. Object-oriented programming","text":"<p>Object-oriented programming (OOP) is a programming paradigm based on the concept of \"objects\", which can contain data and code: data in the form of fields (often known as attributes), and code, in the form of procedures (often known as methods).</p> <p>In Python, classes are used to create objects (instances), and each object can have attributes and behaviors. Let's dive into it with a simple example.</p>"},{"location":"07_oop/#71-classes-and-instances","title":"7.1. Classes and Instances","text":"<p>A Class is like an object constructor, or a \"blueprint\" for creating objects. In Python, we define a class using the class keyword.</p> <p>Here when we say data and functions, we mean attributes and methods. The method here is associated with one class.</p> <p>Let's create a simple class called <code>PetEmployee</code>.</p> Input<pre><code>class PetEmployee:\npass\n</code></pre> <p>Python has a keyword pass that is used as a placeholder. It is syntactically needed for the code to be valid Python, but doesn't actually do anything. In this case, we're using it because we're declaring a class but don't want to put anything inside it yet.</p> <p>The <code>PetEmployee</code> class doesn't currently have any attributes or methods. But it's still a valid class, and we can still create instances of it:</p> <p>Input<pre><code>barkalot = PetEmployee()\nfurrytail = PetEmployee()\nprint(barkalot)\nprint(furrytail)\n</code></pre> Here, barkalot and furrytail are instances of the PetEmployee class. When we print them, we'll see the memory address where these objects are stored in wer machine's memory:</p> <p>Output<pre><code>&lt;__main__.Pet object at 0x0000020E4F6F4E80&gt;\n&lt;__main__.Pet object at 0x0000020E4F6F4F10&gt;\n</code></pre> The output <code>&lt;__main__.Pet object at 0x0000020E4F6F4E80&gt;</code> is telling we that <code>barkalot</code> is an object of type <code>PetEmployee</code>, and it's at the memory location <code>0x0000020E4F6F4E80</code>. The specific memory address we see will be different every time we run the program.</p> <p>These objects don't have any attributes or methods yet, but since they're different instances, they're not identical \u2013 they exist independently of each other in different parts of memory.</p>"},{"location":"07_oop/#711-attributes-and-init-method","title":"7.1.1. Attributes and init method","text":"<p>The initial snippet shows us how we can add attributes to instances of a class. Here, we're manually adding attributes such as <code>name</code>, <code>age</code>, <code>species</code>, <code>email</code>, and <code>level</code> to the instances barkalot and furrytail of the PetEmployee class. These attributes are just variables that are associated with each instance of the class.</p> Input<pre><code>barkalot.name = \"Barkalot\"\nbarkalot.age = 3\nbarkalot.species = \"Dog\"\nbarkalot.email = 'barkalot.dog@gmail.com'\nbarkalot.level = 5\nfurrytail.name = \"Furrytail\"\nfurrytail.age = 2\nfurrytail.species = \"Cat\"\nfurrytail.email = 'furrytail.cat@gmail.com'\nfurrytail.level = 11\nprint(barkalot.name)\nprint(furrytail.name)\n</code></pre> Output<pre><code>Barkalot\nFurrytail\n</code></pre> <p>However, this is not the most efficient way to set up our class. It's manual, repetitive, and prone to error (we might forget to initialize an attribute, or make a typo in the attribute name).</p> <p><code>__init__</code> method</p> <p>The <code>__init__</code> method in Python is similar to constructors in other programming languages. It gets called when we create a new instance of a class. we can use it to set up attributes that every instance of the class should have when it gets created.</p> <p>Input<pre><code>class PetEmployee:\n# Of course, we can use other names instead of self. But it is a convention to use self.\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\n</code></pre> Here, <code>self</code> represents the instance of the class. By using the <code>self</code> keyword we can access the attributes and methods of the class in python.</p> <p>When we create new <code>PetEmployee</code> instances, we now pass in the initial values for <code>name</code>, <code>age</code>, <code>species</code>, and <code>level</code>:</p> Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 5)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 11)\n</code></pre> <p>We can then access these attributes using dot notation:</p> Input<pre><code>print(barkalot.name)\nprint(furrytail.name)\n</code></pre> Output<pre><code>Barkalot\nFurrytail\n</code></pre> <p>This will print the names of <code>barkalot</code> and <code>furrytail</code>. The key thing to note here is that the name attribute for <code>barkalot</code> and <code>furrytail</code> are separate - changing the name attribute for <code>barkalot</code> won't affect <code>furrytail</code>'s name attribute, and vice versa.</p>"},{"location":"07_oop/#712-methods","title":"7.1.2. Methods","text":"<p>A method is simply a function that is associated with an object. In the context of classes, methods often operate on data attributes of the class instances.</p> <p>The first few lines show how to manually concatenate the <code>name</code> and <code>species</code> of a <code>PetEmployee</code> instance:</p> <p>Input<pre><code>print('{} {}'.format(barkalot.name, barkalot.species))\n</code></pre> Output<pre><code>Barkalot Dog\n</code></pre></p> <p>This works, but it would be more elegant and maintainable to define a method within the <code>PetEmployee</code> class to do this for us:</p> <p>Class<pre><code>class PetEmployee:\n# Of course, we can use other names instead of self. But it is a convention to use self.\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\n</code></pre> This <code>fullname</code> method returns a string that is a concatenation of the <code>name</code> and <code>species</code> attributes of a <code>PetEmployee</code> instance. To call this method, we would use the following syntax:</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 5)\n# we need the parenthesis here because fullname is a method not a attributes as the above\nprint(barkalot.fullname())\n</code></pre> Output<pre><code>Barkalot Dog\n</code></pre> Note the parentheses after <code>fullname</code>. This is because <code>fullname</code> is a method, not an attribute. If we forget the parentheses, Python will return the method itself, not the result of the method.</p> <p>we can also call the method on the class, passing the instance as an argument:</p> <p>Input<pre><code>print(PetEmployee.fullname(barkalot))\n</code></pre> Output<pre><code>Barkalot Dog\n</code></pre> In Python, instance methods need to have <code>self</code> as their first parameter so that they can access instance attributes and other instance methods. This is a Python convention. When we call a method on an object, Python automatically passes the object as the first argument. That's why we need to include <code>self</code> in the method definition.</p> <p>Why we need to put self in the method?</p> <p>If we don't put self in the method, we will get an error.</p> <p>Input<pre><code>class PetEmployee:\n# Of course, we can use other names instead of self. But it is a convention to use self.\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname():\nreturn '{} {}'.format(self.name, self.species)\nbarkalot = PetEmployee('Barkalot', 3, 'Dog', 5)\nprint(barkalot.fullname())\n</code></pre> Output<pre><code>TypeError: fullname() takes 0 positional arguments but 1 was given\n</code></pre></p> <p>This is because when we call the method, the instance <code>barkalot</code> is passed as the first argument to the method.</p>"},{"location":"07_oop/#72-class-and-instance-variables","title":"7.2. Class and Instance Variables","text":"<p>Class variables and instance variables are the two types of variables that we can define in a Python class. Both are useful in different scenarios, and understanding them is crucial for effective object-oriented programming in Python.</p> <p>Instance Variables: Instance variables are associated with instances of the class. This means that for each object or instance of a class, the instance variables are different. Instance variables are defined within methods and are prefixed with the self keyword. They are useful when the value of a variable may differ from one instance of a class to another. For example, in a PetEmployee class, each pet will have a unique name, age, and species, so these would be instance variables.</p> <p>Class Variables: Class variables are variables that are shared among all instances of a class. They are not defined inside any methods, and they don't have the self prefix. Class variables are useful when we want a variable to be the same for every instance of a class. For example, if we wanted to apply a uniform promotion increment to all PetEmployee instances, we might define a class variable like promotion_increment = 1.</p> <p>In summary, class variables are shared by all instances of a class, while instance variables can have different values for each class instance. Knowing when to use class variables versus instance variables is essential for creating efficient and organized code in Python.</p>"},{"location":"07_oop/#721-instance-variables","title":"7.2.1. Instance Variables","text":"<p>Let's add some instance variables to our <code>PetEmployee</code> class. We'll add <code>level</code> instance variable to the <code>PetEmployee</code> class, and we'll set them to the values passed in when the instance is created:</p> Input<pre><code>class PetEmployee:\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# Apply promotion to the level of the pet employee\nself.level = self.level + 1\n</code></pre> <p>In this code, a class named <code>PetEmployee</code> is created, which has data attributes such as <code>name</code>, <code>age</code>, <code>species</code>, <code>email</code>, and <code>level</code>. It also includes two methods: <code>fullname</code> and <code>apply_promotion</code>. </p> <p>The <code>fullname</code> method returns a formatted string that concatenates the <code>name</code> and <code>species</code> attributes of the <code>PetEmployee</code> instance, as previously explained.</p> <p>The <code>apply_promotion</code> method increases the <code>level</code> attribute of the <code>PetEmployee</code> instance by 1. In this context, we might consider <code>level</code> as an indication of the employee's rank or position - as the <code>apply_promotion</code> method is called, the <code>level</code> attribute increases, signifying a promotion.</p> <p>Here's a walkthrough of what happens when the script is run:</p> <ol> <li> <p>Two instances of <code>PetEmployee</code> are created, <code>barkalot</code> and <code>furrytail</code>, with the given attributes.</p> </li> <li> <p>The <code>level</code> attribute of the <code>barkalot</code> instance is printed out, which shows 3 as per the initial data given at instance creation.</p> </li> <li> <p>The <code>apply_promotion</code> method is then called on the <code>barkalot</code> instance, which increments <code>barkalot</code>'s <code>level</code> attribute by 1.</p> </li> <li> <p>Printing <code>barkalot.level</code> now shows 4, confirming that the <code>apply_promotion</code> method has successfully incremented the <code>level</code>.</p> </li> </ol> <p><code>self</code></p> <p>Of course, we can use other names instead of <code>self</code>. But it is a convention to use <code>self</code>.</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\nprint(barkalot.level)\nbarkalot.apply_promotion()\nprint(barkalot.level)\n</code></pre> Output<pre><code>3\n4\n</code></pre></p>"},{"location":"07_oop/#722-class-variables","title":"7.2.2. Class Variables","text":"<p>What if we want to change the promotion rate? We don't want to change the promotion rate for each instance mannually.</p> <p>We can use class variable to do this.</p> Input<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self\n# or PetEmployee.promotion_rate\nself.level = self.level + self.promotion_rate \n</code></pre> <p>In the revised <code>PetEmployee</code> class, a class variable <code>promotion_rate</code> is introduced. Class variables are variables that are shared across all instances of the class - unlike instance variables, which can have different values for each instance. </p> <p>In this case, <code>promotion_rate</code> determines how much an employee's <code>level</code> will increase each time the <code>apply_promotion</code> method is called. Since it's a class variable, changing <code>promotion_rate</code> will affect all instances of <code>PetEmployee</code>, not just one.</p> <p>The <code>apply_promotion</code> method is adjusted to use <code>self.promotion_rate</code> when increasing the <code>level</code> attribute. The <code>self</code> keyword ensures that the instance refers to the class variable, not a potential instance variable of the same name. This way, if <code>promotion_rate</code> is changed for the <code>PetEmployee</code> class, all instances will use the new rate when <code>apply_promotion</code> is called.</p> <p>In this current setting, calling <code>apply_promotion</code> on either <code>barkalot</code> or <code>furrytail</code> will increment their <code>level</code> attribute by 1, as the <code>promotion_rate</code> is set to 1.</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\n# How to understand this?\n# Here we print out the promotion rate of the class and the instance.\n# The promotion rate of the instance is the same as the class.\nprint(PetEmployee.promotion_rate)\nprint(barkalot.promotion_rate)\nprint(furrytail.promotion_rate)\n</code></pre> Output<pre><code>1\n1\n1\n</code></pre></p> <p>The Sequence of Attribute Lookup</p> <p>When we access the attribute of an instance, it will first check if the instance has the attribute.</p> <p>If not, it will check if the class has the attribute.</p> <p>If not, it will check if the parent class has the attribute.</p> <p>Here, the instance doesn't have the promotion_rate attribute, so it will check the class.</p> <p>The class has the promotion_rate attribute, so it will use the class attribute.</p> <p>When we first create the <code>barkalot</code> and <code>furrytail</code> instances, they don't have an instance variable called <code>promotion_rate</code>. So when we try to access <code>barkalot.promotion_rate</code> or <code>furrytail.promotion_rate</code>, Python doesn't find the attribute in the instance's <code>__dict__</code>. In this case, Python falls back to the class (<code>PetEmployee</code>) and checks if <code>PetEmployee</code> has an attribute <code>promotion_rate</code>, which it does.</p> <p>Now let's lookup the <code>__dict__</code> attribute of the class and the instance.</p> <p>Input<pre><code>print(barkalot.__dict__)\nprint(PetEmployee.__dict__)\n</code></pre> Output<pre><code>{'name': 'Barkalot', 'age': 3, 'species': 'Dog', 'email': 'Barkalot.Dog@gmail.com', 'level': 3}\n{'__module__': '__main__', 'promotion_rate': 1, '__init__': &lt;function PetEmployee.__init__ at 0x000001B8AD52D940&gt;, ...}\n</code></pre> The output contains the attribute <code>promotion_rate</code> for the class PetEmployee.</p> <p>When we modify the <code>promotion_rate</code> attribute of the <code>PetEmployee</code> class, it affects both <code>barkalot</code> and <code>furrytail</code> because they fall back to the class attribute when their own <code>promotion_rate</code> attribute is not found.</p> <p>Input<pre><code>PetEmployee.promotion_rate = 2\nprint(PetEmployee.promotion_rate)\nprint(barkalot.promotion_rate)\nprint(furrytail.promotion_rate)\n</code></pre> Output<pre><code>2\n2\n2\n</code></pre></p> <p>However, when we set <code>barkalot.promotion_rate = 3</code>, we're creating an instance attribute <code>promotion_rate</code> specific to <code>barkalot</code>. Now when we try to access <code>barkalot.promotion_rate</code>, Python finds it in the <code>barkalot</code> instance's <code>__dict__</code> and doesn't need to fall back to the class attribute. Therefore, <code>barkalot.promotion_rate</code> shows <code>3</code>, while <code>furrytail.promotion_rate</code> and <code>PetEmployee.promotion_rate</code> still show <code>2</code>.</p> <p>Input<pre><code>barkalot.promotion_rate = 3\nprint(PetEmployee.promotion_rate)\nprint(barkalot.promotion_rate)\nprint(furrytail.promotion_rate)\n</code></pre> Output<pre><code>2\n3\n2\n</code></pre> Also check <code>__dict__</code> again.</p> <p>Input<pre><code>print(barkalot.__dict__)\n</code></pre> Output<pre><code>{'name': 'Barkalot', 'age': 3, 'species': 'Dog', 'email': 'Barkalot.Dog@gmail.com', 'level': 3, 'promotion_rate': 3}\n</code></pre></p> <p>This demonstrates how class variables and instance variables in Python work and the difference between them. Class variables are shared among all instances of a class unless specifically overridden within an instance, as we did with <code>barkalot</code>.</p> <p>Here we introduce an extra usage of class variables: counting the number of instances (objects) created for a class. This is handy if we want to keep track of how many pet employees we've hired so far. I can imagine the HR department being pretty grateful for this feature. (I mean, it would be quite embarrassing if they lost track of how many pets they've hired, right?)</p>"},{"location":"07_oop/#723-example","title":"7.2.3. Example","text":"<p>Counting the Number of Instances</p> <p>Here we want to count the number of employees when we create a new emplyee instance.</p> <p>Input<pre><code># Here we want to count the number of employees when we create a new emplyee instance.\nclass PetEmployee:\n# Class variable\nnum_of_pet_employees = 0\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\nPetEmployee.num_of_pet_employees += 1\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n</code></pre> In this iteration of <code>PetEmployee</code>, we introduce a new class variable: <code>num_of_pet_employees</code>. This variable is incremented each time a new <code>PetEmployee</code> instance is created, thanks to the magic line <code>PetEmployee.num_of_pet_employees += 1</code> in the <code>__init__</code> method. Remember, <code>__init__</code> is called each time we instantiate a new object, making it the perfect place to keep count of our newly employed pets.</p> <p>Here's how it works: Input<pre><code>print(PetEmployee.num_of_pet_employees)\n</code></pre> Output<pre><code>0\n</code></pre> We haven't created any instances of <code>PetEmployee</code> yet, so our pet employee count is a big, fat zero. HR is twiddling their thumbs, waiting for some action.</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\n</code></pre> Hold onto your hats, HR, we just employed two new pets! <code>barkalot</code> and <code>furrytail</code> join the team, and <code>PetEmployee.num_of_pet_employees</code> is incremented each time, thanks to our handy <code>__init__</code> method.</p> <p>Input<pre><code>print(PetEmployee.num_of_pet_employees)\n</code></pre> Output<pre><code>2\n</code></pre> Voila! HR breathes a sigh of relief. They didn't have to count on their paws - our class variable did the job for them.</p> <p>This example showcases how a class variable can be used as a handy counter for all instances of a class. It's one of those Python tricks that makes your life as a developer easier and helps you keep track of the state of your program.</p>"},{"location":"07_oop/#724-exercise","title":"7.2.4. Exercise","text":"<p>Let's go one step further and imagine a scenario where HR wants to know which species they've employed most. Here's a little exercise for you: Can you modify our <code>PetEmployee</code> class to keep track of how many Dogs and Cats they've hired? (Hint: You might want to use a dictionary as a class variable!) </p> <p>Which Pet Employee Species Do We Have the Most Of?</p> SkeletonSolution Input<pre><code>class PetEmployee:\nnum_of_pet_employees = 0\nspecies_count = {}\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\nPetEmployee.num_of_pet_employees += 1\n# Updating species count\n# Your code here\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\nself.level = self.level + self.promotion_rate\n</code></pre> <p>Input<pre><code>class PetEmployee:\nnum_of_pet_employees = 0\nspecies_count = {}\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\nPetEmployee.num_of_pet_employees += 1\n# Updating species count\nif species in PetEmployee.species_count:\nPetEmployee.species_count[species] += 1\nelse:\nPetEmployee.species_count[species] = 1\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\nself.level = self.level + self.promotion_rate\n</code></pre> Now, each time a <code>PetEmployee</code> is created, <code>species_count</code> is updated. Let's create some instances and see how it works: Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\nmewton = PetEmployee('Mewton', 4, 'Cat', 7)\n</code></pre> Input<pre><code>print(PetEmployee.species_count)\n</code></pre> Output<pre><code>{'Dog': 1, 'Cat': 2}\n</code></pre></p>"},{"location":"07_oop/#73-classmethods-and-staticmethods","title":"7.3. Classmethods and Staticmethods","text":"<p>Alright, let's dive into the magical world of Python's <code>classmethods</code> and <code>staticmethods</code>!</p> <p>In addition to instance methods, which operate on individual objects (or \"instances\"), Python classes can also have <code>classmethods</code> and <code>staticmethods</code>. </p> <p>We'll kick things off by looking at <code>classmethods</code>.</p>"},{"location":"07_oop/#731-classmethods","title":"7.3.1. Classmethods","text":"<p>To create a class method in Python, we use the <code>@classmethod</code> decorator and the special <code>cls</code> parameter, which points to the class, not the instance of the object.</p> <p>In our example code, we have a class <code>PetEmployee</code> with a class variable <code>promotion_rate</code>. Let's dive into the details:</p> Input<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n@classmethod\ndef set_promotion_rate(cls, rate):\ncls.promotion_rate = rate\n</code></pre> <p>Here, we have the <code>set_promotion_rate</code> class method. This method changes the <code>promotion_rate</code> for all instances of the class, not just for one instance. </p> <p>So, if we have two pet employees, Barkalot and Furrytail:</p> Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\n</code></pre> <p>And we print their <code>promotion_rate</code>, we get <code>1</code> for both as the class variable <code>promotion_rate</code> is set to <code>1</code>:</p> <p>Input<pre><code>print(PetEmployee.promotion_rate)\nprint(barkalot.promotion_rate)\nprint(furrytail.promotion_rate)\n</code></pre> Output<pre><code>1\n1\n1\n</code></pre></p> <p>But what happens if we change the <code>promotion_rate</code> using the <code>set_promotion_rate</code> class method? </p> Input<pre><code>PetEmployee.set_promotion_rate(2)\n</code></pre> <p>Boom! The promotion rate changes for both Barkalot and Furrytail. That's the power of class methods:</p> <p>Input<pre><code>print(PetEmployee.promotion_rate)\nprint(barkalot.promotion_rate)\nprint(furrytail.promotion_rate)\n</code></pre> Output<pre><code>2\n2\n2\n</code></pre></p> <p>Classmethods as Alternative Constructors</p> <p>Classmethods are also commonly used as alternative constructors. This means they can provide additional ways to create objects.</p> <p>For instance, suppose we have pet employee data as a hyphen-separated string. We can use a class method to parse this string and create a new <code>PetEmployee</code> object. </p> Input<pre><code>@classmethod\ndef from_string(cls, emp_str):\nname, age, species, level = emp_str.split('-')\nreturn cls(name, age, species, level)\n</code></pre> <p>And we can easily create a new <code>PetEmployee</code> using this new class method:</p> <p>Input<pre><code>barkalot_str = 'Barkalot-3-Dog-3'\nfurrytail_str = 'Furry\nbarkalot = PetEmployee.from_string(barkalot_str)\nfurrytail = PetEmployee.from_string(furrytail_str)\nprint(barkalot.fullname())\n</code></pre> Output<pre><code>Barkalot Dog\n</code></pre></p> <p>With one line of code, we've turned a string into a full-fledged <code>PetEmployee</code> object! Who's a good boy? <code>classmethod</code>, you're a good boy!</p> <p>Now, we've tackled class methods like pros. Let's tease apart static methods, shall we?</p>"},{"location":"07_oop/#732-staticmethods","title":"7.3.2. Staticmethods","text":"<p>Static methods don't access or modify any instance or class data. They're more like handy utility functions we bundle with the class. They're defined using the <code>@staticmethod</code> decorator.</p> Input<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n@classmethod\ndef set_promotion_rate(cls, rate):\ncls.promotion_rate = rate\n@classmethod\ndef from_string(cls, emp_str):\nname, age, species, level = emp_str.split('-')\nreturn cls(name, age, species, level)\n@staticmethod\ndef is_walking_pet_today(day):\nif day.weekday() == 6:\nreturn 'Yaay! It\\'s time to walk the pets!'\nreturn 'Sorry, you have to get back to work!'\n</code></pre> <p>Let's update our <code>PetEmployee</code> class with a static method that checks if <code>is_walking_pet_today</code>:</p> Input<pre><code>@staticmethod\ndef is_walking_pet_today(day):\nif day.weekday() == 6:\nreturn 'Yaay! It\\'s time to walk the pets!'\nreturn 'Sorry, you have to get back to work!'\n</code></pre> Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\n</code></pre> <p>This method doesn't rely on any specific instance or class variable, making it a perfect candidate for a static method. It takes in a date and checks if it's a Sunday (weekday <code>6</code>). If so, it returns a cheerful message encouraging pet walks. Otherwise, it sadly informs you to get back to work. No fun!</p> <p>We can call this static method without any instance, just by using the class name: Input<pre><code>import datetime\ntoday_date = datetime.date.today()\nprint(PetEmployee.is_walking_pet_today(today_date))\n</code></pre> Output<pre><code>Yaay! It's time to walk the pets!\n</code></pre></p> <p>This block of code imports the <code>datetime</code> module, gets today's date, and then checks if it's a pet walking day according to our <code>PetEmployee</code> guidelines. </p> <p>One minor correction I'd like to point out is that the output wouldn't be <code>False</code>, but rather one of the two strings our method returns: <code>'Yaay! It's time to walk the pets!'</code> or <code>'Sorry, you have to get back to work!'</code>, depending on the day of the week.</p>"},{"location":"07_oop/#74-inheritance","title":"7.4. Inheritance","text":"<p>Inheritance allows us to create a new class using details of an existing class without modifying it. This is like saying, \"Hey, I like what you've done here. I'll take it, and add a little sprinkle of my own magic.\"</p>"},{"location":"07_oop/#741-creating-subclasses","title":"7.4.1. Creating Subclasses","text":"Initial Class Setup<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n</code></pre> <p>In our example, we're creating a new class <code>PetDataScientist</code> that inherits from our existing <code>PetEmployee</code> class:</p> Input<pre><code># Subclass of PetEmployee\nclass PetDataScientist(PetEmployee):\npass\n</code></pre> <p>Here, <code>pass</code> is a placeholder because Python expects an indented block for classes. It says, \"I don't want to add anything new in this class, just use everything from <code>PetEmployee</code>.\"</p> <p>So, when we create <code>PetDataScientist</code> instances, they have access to the same attributes and methods as <code>PetEmployee</code> instances:</p> Input<pre><code>barkalot = PetDataScientist('Barkalot', 3, 'Dog', 3)\nfurrytail = PetDataScientist('Furrytail', 2, 'Cat', 5)\nprint(barkalot.email)\nprint(furrytail.email)\n</code></pre> Output<pre><code>Barkalot.Dog@gmail.com\nFurrytail.Cat@gmail.com\n</code></pre> <p>You can see that <code>barkalot</code> and <code>furrytail</code>, even though they're data scientist pets (probably discussing the latest in machine learning algorithms), have emails formatted the same way as any <code>PetEmployee</code>. That's inheritance in action!</p> <p>One cool feature Python provides is the <code>help</code> function. This function displays important details about a class, including its Method Resolution Order (MRO). The MRO is the order in which Python looks for a method in a hierarchy of classes. Here, it tells us that when looking for a method, Python first checks <code>PetDataScientist</code>, then <code>PetEmployee</code>, and finally the built-in <code>object</code> class that every class implicitly inherits from:</p> <p>Input<pre><code>print(help(PetDataScientist))\n</code></pre> Output<pre><code>Method resolution order:\n|      PetDataScientist\n|      PetEmployee\n|      builtins.object\n</code></pre></p> <p>This is just the tip of the inheritance iceberg, and there's so much more to explore. If you're up for it, why don't we add some unique methods to our <code>PetDataScientist</code> class? Maybe a method to analyze data (just pretend data for now) or to present findings? Let your imagination run wild!</p> <p>Now let's create a functional subclass of <code>PetEmployee</code> named <code>PetDataScientist</code>:</p> Child Class - PetDataScientistParent Class - PetEmployee Input<pre><code>class PetDataScientist(PetEmployee):\npromotion_rate = 2\n</code></pre> Initial Class Setup<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n</code></pre> <p>In this piece of code, we redefine <code>promotion_rate</code> for our <code>PetDataScientist</code> class, effectively overriding the <code>promotion_rate</code> of <code>PetEmployee</code> class. You can think of it as saying, \"PetEmployee, you did a good job with the promotion rate, but we data scientist pets need it to be a bit faster. So we'll take it from here.\"</p> <p>Now when a <code>PetDataScientist</code> applies for a promotion:</p> Input<pre><code>barkalot = PetDataScientist('Barkalot', 3, 'Dog', 3)\nprint(barkalot.level)\nbarkalot.apply_promotion()\nprint(barkalot.level)\n</code></pre> Output<pre><code>3\n5\n</code></pre> <p>Barkalot, the data scientist dog (which is honestly the cutest mental image), receives a promotion of 2 levels, unlike regular <code>PetEmployee</code>s who only advance by 1. The reason is that when <code>apply_promotion()</code> is called, it uses <code>PetDataScientist</code>'s <code>promotion_rate</code>, not <code>PetEmployee</code>'s.</p> <p>This little example shows the power of inheritance. By changing just one line in the subclass, we've changed the behavior of a method inherited from the superclass without having to rewrite the entire method!</p>"},{"location":"07_oop/#742-overriding-methods","title":"7.4.2. Overriding Methods","text":"<p>Barkalot and Furrytail are stepping up their game! Not only are they data scientists, but they also have their favorite programming languages now. Let's see how you've accomplished this:</p> Child Class - PetDataScientistParent Class - PetEmployee Input<pre><code>class PetDataScientist(PetEmployee):\npromotion_rate = 2\ndef __init__(self, name, age, species, level, language):\nsuper().__init__(name, age, species, level)\nself.language = language\n</code></pre> Initial Class Setup<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n</code></pre> <p>In this code, you have overridden the <code>__init__</code> method in the <code>PetDataScientist</code> subclass. You've added a new parameter <code>language</code> to keep track of the favorite programming language of our data scientist pets.</p> <p>The magic happens in this line: <code>super().__init__(name, age, species, level)</code>. The <code>super()</code> function is like a time machine that brings us to the parent class, <code>PetEmployee</code> in this case. When we call <code>super().__init__(name, age, species, level)</code>, it executes the <code>__init__</code> method from <code>PetEmployee</code>, initializing the common attributes.</p> <p>Then we come back to the future (or the <code>PetDataScientist</code> class) and add the new attribute <code>language</code>.</p> Input<pre><code>ds_barkalot = PetDataScientist('Barkalot', 3, 'Dog', 3, 'Python')\nds_furrytail = PetDataScientist('Furrytail', 2, 'Cat', 5, 'Mojo')\nprint(ds_barkalot.language)\n</code></pre> Output<pre><code>'Python'\n</code></pre> <p>When we create a <code>PetDataScientist</code> instance like <code>ds_barkalot</code>, we can now provide a programming language. Barkalot prefers Python, just like us!</p> <p>Inheritance and overriding allow us to extend and modify behavior without disturbing the existing class. Quite neat, isn't it? </p> <p>One more child class - PetLeader</p> <p>Let's dive into the marvelous world of team management.</p> Child Class - PetLeaderChild Class - PetDataScientistParent Class - PetEmployee Input<pre><code>class PetLeader(PetEmployee):\npromotion_rate = 1\ndef __init__(self, name, age, species, level, team=None):\nsuper().__init__(name, age, species, level)\nif team is None:\nself.team = []\nelse:\nself.team = team\ndef add_team_member(self, employee):\nif employee not in self.team:\nself.team.append(employee)\ndef remove_team_member(self, employee):\nif employee in self.team:\nself.team.remove(employee)\ndef print_team(self):\nfor employee in self.team:\nprint(' ', employee.fullname())\n</code></pre> Input<pre><code>class PetDataScientist(PetEmployee):\npromotion_rate = 2\ndef __init__(self, name, age, species, level, language):\nsuper().__init__(name, age, species, level)\nself.language = language\n</code></pre> Initial Class Setup<pre><code>class PetEmployee:\n# Class variable\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\n# We need to use the class name to access the class variable\n# This can be either self or PetEmployee\nself.level = self.level + self.promotion_rate\n</code></pre> <p>Here, you've introduced a new subclass <code>PetLeader</code> that inherits from <code>PetEmployee</code>. It includes a new instance variable <code>team</code>, which is a list of <code>PetEmployee</code> objects. A <code>PetLeader</code> has the ability to manage a team, adding and removing team members with the <code>add_team_member()</code> and <code>remove_team_member()</code> methods, respectively. They can also print their team with the <code>print_team()</code> method, showing us the full names of their team members.</p> <p>Then you've created some instances and made Barkalot a leader:</p> <p>Input<pre><code>ds_barkalot = PetDataScientist('Barkalot', 3, 'Dog', 3, 'Python')\nds_furrytail = PetDataScientist('Furrytail', 2, 'Cat', 5, 'Mojo')\nmanager_whiskers = PetLeader('Whiskers', 5, 'Cat', 5, [ds_barkalot])\nmanager_whiskers.print_team()\n</code></pre> Output<pre><code>Barkalot Dog\n</code></pre> Add furrytail to Barkalot's team:</p> <p>Input<pre><code>manager_barkalot.add_team_member(ds_furrytail)\nmanager_barkalot.print_team()\n</code></pre> Output<pre><code> Barkalot Dog\nFurrytail Cat\n</code></pre></p> <p>You've shown us how <code>isinstance()</code> and <code>issubclass()</code> functions work. <code>isinstance()</code> checks if an object is an instance of a class or its subclasses, while <code>issubclass()</code> checks if a class is a subclass of another. It's like an identity card for our classes and objects.</p> <p>Input<pre><code>print(isinstance(manager_whiskers, PetLeader))\nprint(isinstance(manager_whiskers, PetDataScientist))\n</code></pre> Output<pre><code>True\nFalse\n</code></pre></p> <p>Input<pre><code>print(issubclass(PetLeader, PetEmployee))\nprint(issubclass(PetDataScientist, PetLeader))\n</code></pre> Output<pre><code>True\nFalse\n</code></pre></p> <p>These tools can be handy when we want to verify the relationships between objects and classes.</p> <p>Now that we've got a manager, perhaps we could consider a task or project class for the team to work on. What do you think?</p>"},{"location":"07_oop/#75-polymorphism","title":"7.5. Polymorphism","text":"<p>Ah, polymorphism! The magical concept in object-oriented programming that allows objects to take on many forms. It's like our pets morphing into different roles in the company at runtime!</p> <p>First, we need to understand what polymorphism is. It refers to the ability of an object to behave in multiple ways. This comes from Greek, where 'poly' means 'many', and 'morph' means 'form'. In programming, it's the ability of a function or a method to behave differently based on the object that calls it.</p> <p>Let's use our <code>PetEmployee</code>, <code>PetDataScientist</code>, and <code>PetLeader</code> classes to illustrate the concept.</p> Input<pre><code>class PetEmployee:\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\nself.level = self.level + self.promotion_rate\ndef daily_duty(self):\nreturn \"Work! Work! Work!\"\nclass PetDataScientist(PetEmployee):\npromotion_rate = 2\ndef __init__(self, name, age, species, level, language):\nsuper().__init__(name, age, species, level)\nself.language = language\ndef daily_duty(self):\nreturn \"Importing data, analyzing data, and drinking coffee\"\nclass PetLeader(PetEmployee):\npromotion_rate = 1\ndef __init__(self, name, age, species, level, team=None):\nsuper().__init__(name, age, species, level)\nif team is None:\nself.team = []\nelse:\nself.team = team\ndef daily_duty(self):\nreturn \"Managing team and setting goals\"\ndef pet_daily_duty(pet):\nprint(pet.daily_duty())\n</code></pre> Input<pre><code>emp_barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nds_furrytail = PetDataScientist('Furrytail', 2, 'Cat', 5, 'Python')\nmanager_whiskers = PetLeader('Whiskers', 5, 'Cat', 5)\npets = [emp_barkalot, ds_furrytail, manager_whiskers]\nfor pet in pets:\npet_daily_duty(pet)\n</code></pre> Output<pre><code>Work! Work! Work!\nImporting data, analyzing data, and drinking coffee\nLead team and setting goals\n</code></pre> <p>The <code>daily_duty()</code> method has different implementations in the <code>PetEmployee</code>, <code>PetDataScientist</code>, and <code>PetLeader</code> classes. When we call <code>daily_duty()</code> on an object, the appropriate method is selected based on the object's class, not the type of the variable that is used to call the method. This is a classic example of polymorphism.</p> <p><code>raise</code> keyword</p> <p>In Python, <code>raise</code> is a keyword that's used to generate exceptions. By invoking <code>raise</code>, you're signaling to Python that an error has occurred, and you're asking Python to stop the normal execution of your program and instead, to \"throw\" an error that needs to be caught and handled.</p> <p>Now, let's talk about <code>NotImplementedError</code>. This is a special type of exception that we raise when we have a method or function that is supposed to be implemented by a subclass. It's effectively a way of saying, \"Hey, if you're seeing this error, it means you've forgotten to implement this method in your subclass.\"</p> <p>So when we define a method as follows in the PetEmployee class:</p> PetEmployee class<pre><code>def daily_duty(self):\nraise NotImplementedError(\"Implement this abstract method in a subclass\")\n</code></pre> <p>It's like we're putting up a big neon sign saying \"Hey, this method needs to be implemented in any subclass that uses it\".</p> <p>The difference between <code>NotImplementedError</code> and other types of exceptions is really just about semantics and when they're used. We raise a <code>NotImplementedError</code> when we're creating a method that is supposed to be overridden by a subclass.</p>"},{"location":"07_oop/#76-magic-methods","title":"7.6. Magic Methods","text":""},{"location":"07_oop/#761-__repr__-and-__str__","title":"7.6.1. <code>__repr__</code> and <code>__str__</code>","text":"<p>We are about to plunge into the wacky world of Magic (or Dunder) Methods in Python. These methods are special functions with double underscores at the start and end of their names (e.g., <code>__init__</code>, <code>__repr__</code>, <code>__str__</code>), hence the nickname \"Dunder\" (from Double UNDERscore).</p> <p>Now, let's dissect our code here, which depicts a class <code>PetEmployee</code> we created in the previous sections:</p> Input<pre><code>class PetEmployee:\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\nself.level = self.level + self.promotion_rate\ndef __repr__(self):\nreturn \"PetEmployee('{}', {}, '{}', {})\".format(self.name, self.age, self.species, self.level)\ndef __str__(self):\nreturn '{}, {}'.format(self.fullname(), self.species)\n</code></pre> <p>In this class, we've implemented two magic methods, <code>__repr__</code> and <code>__str__</code>. They are used to represent our objects in different ways.</p> <p>The <code>__repr__</code> method returns a string that represents the exact state of the object. This is super useful for debugging and logging, as it provides a complete representation of the object, which we could use to recreate it. </p> <p>The <code>__str__</code> method, on the other hand, is more user-friendly. It returns a string that represents the object in a way that is easy to read. This is what is displayed to the end user.</p> <p>Let's say we create two <code>PetEmployee</code> instances:</p> <pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\n</code></pre> <p>Before defining <code>__repr__</code> and <code>__str__</code>, printing <code>barkalot</code> would give something like <code>&lt;__main__.PetEmployee object at 0x0000020E0F6F6F98&gt;</code>. Not so informative, right? It's just telling us that <code>barkalot</code> is an object of <code>PetEmployee</code> class at a specific memory address.</p> <p>However, after defining these methods:</p> Input<pre><code>print(repr(barkalot))\nprint(str(barkalot))\n</code></pre> <p>The output now becomes much more informative:</p> Output<pre><code>\"PetEmployee('Barkalot', 3, 'Dog', 3)\"\n\"Barkalot Dog\"\n</code></pre> <p>The first one is the <code>__repr__</code> output, which provides a complete representation of the <code>barkalot</code> object. The second one is the <code>__str__</code> output, which is more human-readable and pleasant to the eye. Now we're talking!</p> <p>Remember, folks, the magic of Dunder methods lies in their ability to let us customize Python class behavior in powerful ways. These methods open the door to a whole new world of possibilities! So go ahead and try using them in your own classes. You'll be amazed at what you can achieve! </p>"},{"location":"07_oop/#762-__add__-and-__len__","title":"7.6.2. <code>__add__</code> and <code>__len__</code>","text":"<p>Let's go over the code snippet provided:</p> Input<pre><code>class PetEmployee:\npromotion_rate = 1\ndef __init__(self, name, age, species, level):\nself.name = name\nself.age = age\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\nself.level = level\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\ndef apply_promotion(self):\nself.level = self.level + self.promotion_rate\ndef __repr__(self):\nreturn \"PetEmployee('{}', {}, '{}', {})\".format(self.name, self.age, self.species, self.level)\ndef __str__(self):\nreturn '{}, {}'.format(self.fullname(), self.species)\ndef __add__(self, other):\nreturn self.level + other.level\ndef __len__(self):\nreturn len(self.species)\n</code></pre> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 3, 'Dog', 3)\nfurrytail = PetEmployee('Furrytail', 2, 'Cat', 5)\nprint(barkalot + furrytail)\nprint(len(barkalot))\n</code></pre> Output<pre><code>8\n3\n</code></pre></p> <p>Now, let's untangle this. We've got two new magic methods on our hands: <code>__add__</code> and <code>__len__</code>.</p> <p>The <code>__add__</code> method allows us to define the behavior for the addition operator <code>+</code>. Here, we've chosen to add the levels of two <code>PetEmployee</code> instances together. It's like saying, \"Hey, Python! When I add two pet employees together, what I really want is to add their levels.\"</p> <p>So, if we were to add <code>barkalot</code> and <code>furrytail</code>:</p> <pre><code>print(barkalot + furrytail)\n# Or print(barkalot.__add__(furrytail))\n</code></pre> <p>We'd get <code>8</code>, because <code>barkalot</code>'s level is <code>3</code> and <code>furrytail</code>'s level is <code>5</code>. Quick math, folks!</p> <p>Similarly, the <code>__len__</code> method allows us to define behavior for the <code>len()</code> function applied to an instance of our class. Here, it's been defined to return the length of the species name.</p> <p>So, printing <code>len(barkalot)</code>:</p> <pre><code>print(len(barkalot))\n# Or print(barkalot.__len__())\n</code></pre> <p>Would yield <code>3</code>, because the species name 'Dog' has three characters.</p>"},{"location":"07_oop/#77-getters-setters-and-deleters","title":"7.7. Getters, Setters, and Deleters","text":"<p>We're about to delve into the land of Getters, Setters, and Deleters in Python. Picture this, your pet has attributes, like its name, species, and level. These attributes are like the pet's toys. Your pet can fetch these toys, place them somewhere else, or even destroy them (hopefully, they don't do this often). In the coding world, these actions translate to getting, setting, and deleting attributes!</p> <p>Let's take a peek at the magic Python has tucked up its sleeve:</p> GettersSettersDeleters <p>Getters are like a fetching command for your pet. They fetch the value of a private attribute. Python, being the friendly language that it is, makes getters easy to use with the <code>@property</code> decorator. This allows us to access a method as if it were a simple attribute. Here's how it looks:</p> <pre><code>class Pet:\ndef __init__(self, name=None):\nself._name = name\n@property\ndef name(self):\nreturn self._name\n</code></pre> <p>In this example, <code>name</code> is a getter for the private attribute <code>_name</code>.</p> <p>Setters are like telling your pet to place its toy somewhere else. They allow us to set the value of private attributes. We use the <code>@&lt;attribute&gt;.setter</code> decorator to create a setter in Python:</p> <pre><code>class Pet:\ndef __init__(self, name=None):\nself._name = name\n@property\ndef name(self):\nreturn self._name\n@name.setter\ndef name(self, name):\nself._name = name\n</code></pre> <p>Here, <code>@name.setter</code> allows us to set the value of <code>_name</code>.</p> <p>Deleters are like your pet destroying its toy. They allow us to delete attributes. We use the <code>@&lt;attribute&gt;.deleter</code> decorator to create a deleter in Python:</p> <pre><code>class Pet:\ndef __init__(self, name=None):\nself._name = name\n@property\ndef name(self):\nreturn self._name\n@name.setter\ndef name(self, name):\nself._name = name\n@name.deleter\ndef name(self):\ndel self._name\n</code></pre> <p>The <code>@name.deleter</code> allows us to delete <code>_name</code> from our instance.</p> <p>With these magic methods, we can have full control over our class attributes, just like training your pets to handle their toys responsibly. Don't forget to treat your pets, and your code, with care!</p> <p>Next up, we'll see how these getters, setters, and deleters play together in a single class. Keep your coding boots on; it's going to be a thrilling ride!</p>"},{"location":"07_oop/#771-motivation","title":"7.7.1. Motivation","text":"<p>It's time to introduce getters, setters, and deleters - Python's very own magic carpet ride for navigating the world of object attributes. </p> <p>First, let's revisit our initial code:</p> Input<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\nself.email = name + '.' + species + '@gmail.com'\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\nbarkalot = PetEmployee('Barkalot', 'Dog', 3)\nbarkalot.name = 'Furrytail'\nprint(barkalot.name)\nprint(barkalot.fullname())\nprint(barkalot.email)\n</code></pre> Output<pre><code>Furrytail\nFurrytail Dog\nBarkalot.Dog@gmail.com\n</code></pre> <p>Now, upon looking at the output, we can see a big woof-woof. We changed <code>barkalot</code>'s name to 'Furrytail', and the full name changes as expected. But the email stays the same! It's like calling a cat a dog and expecting it to bark. Now, we could manually update the email every time we change the name, but who wants to do all that extra work? Certainly not us!</p>"},{"location":"07_oop/#772-getter","title":"7.7.2. Getter","text":"<p>Now we have two ways to fix the above issue:</p> Define a new instance methodUse a getter @property New instance method<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\ndef email(self):\nreturn \"{}.{}@gmail.com\".format(self.name, self.species)\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\n</code></pre> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 'Dog', 3)\nbarkalot.name = 'Furrytail'\nprint(barkalot.name)\nprint(barkalot.fullname())\nprint(barkalot.email()) # We have to change all instances of email to email()\n</code></pre> Output<pre><code>Furrytail\nFurrytail Dog\nFurrytail.Dog@gmail.com\n</code></pre> The issue we faced was that every time we changed the name of our <code>PetEmployee</code>, we had to manually update the <code>email</code>. So, we turned our email attribute into a method that dynamically generates the email based on the current <code>name</code> and <code>species</code>. Problem solved, right? Well, not exactly. Our solution created a new problem: we have to change every instance of <code>email</code> to <code>email()</code>. Let's check our the other solution.</p> Getter @property<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\n@property\ndef email(self):\nreturn \"{}.{}@gmail.com\".format(self.name, self.species)\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\n</code></pre> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 'Dog', 3)\nbarkalot.name = 'Furrytail'\nprint(barkalot.name)\nprint(barkalot.fullname())\nprint(barkalot.email) # You don't have to change anything!\n</code></pre> Output<pre><code>Furrytail\nFurrytail Dog\nFurrytail.Dog@gmail.com\n</code></pre> In this code, we introduced the <code>@property</code> decorator before our <code>email</code> method. Now we can access it as if it were a simple attribute, no need to write those pesky parentheses. It's just like a self-walking pet; no extra effort required!</p> <p>We've not only kept the functionality of our first solution (dynamically updating the email), but also made it much more user-friendly. This is what we call a win-win situation in the coding world!</p>"},{"location":"07_oop/#773-setter","title":"7.7.3. Setter","text":"<p>We're about to dive into the realm of setters. Setters are kind of like giving your pet a new name. You're setting a new value to an attribute. </p> <p>In Python, we can disguise methods as attributes using the <code>@property</code> decorator. But when we want to set a new value to this \"attribute\", we need a <code>setter</code>. A <code>setter</code> allows us to define custom behavior for setting values. You might think of it as a strict pet owner who insists on a specific way to feed their pet. </p> <p>Here's the code for our <code>PetEmployee</code> class with a <code>setter</code>:</p> Setter<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\n@property\ndef email(self):\nreturn \"{}.{}@gmail.com\".format(self.name, self.species)\n@property\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\n@fullname.setter\ndef fullname(self, name):\nfirst, last = name.split(' ')\nself.name = first\nself.species = last\n</code></pre> <p>Let's dissect this piece of beauty:</p> <ol> <li>We start by initializing our <code>PetEmployee</code> with a <code>name</code>, <code>species</code>, and <code>level</code>.</li> <li>We then create a <code>@property</code> for <code>email</code>, which takes the <code>name</code> and <code>species</code> and creates an email-like string. With this, when we call <code>barkalot.email</code>, Python calls the <code>email</code> method behind the scenes.</li> <li>We do the same for <code>fullname</code>, which gives us a concatenated string of <code>name</code> and <code>species</code>.</li> <li>Then comes the star of our show, the <code>@fullname.setter</code> decorator. This turns our <code>fullname</code> method into a setter, allowing us to assign a new value to <code>fullname</code>. It splits the assigned value into two parts - <code>first</code> and <code>last</code> - and sets <code>name</code> and <code>species</code> respectively.</li> </ol> <p>Finally, we test our code:</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 'Dog', 3)\nbarkalot.fullname = 'Furrytail Cat'\nprint(barkalot.name)  \nprint(barkalot.fullname)  \nprint(barkalot.email)  \n</code></pre> Output<pre><code>Furrytail\nFurrytail Cat\nFurrytail.Cat@gmail.com\n</code></pre></p> <p>Our pet Barkalot has now been successfully renamed to Furrytail, a cat, and his email has changed too. </p>"},{"location":"07_oop/#774-deleter","title":"7.7.4. Deleter","text":"<p>The following code is the class <code>PetEmployee</code> with a deleter:</p> Deleter<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\n@property\ndef email(self):\nreturn \"{}.{}@gmail.com\".format(self.name, self.species)\n@property\ndef fullname(self):\nreturn '{} {}'.format(self.name, self.species)\n@fullname.setter\ndef fullname(self, name):\nfirst, last = name.split(' ')\nself.name = first\nself.species = last\n@fullname.deleter\ndef fullname(self):\nprint('Delete Pet Name!')\nself.name = None\nself.species = None\n</code></pre> <p>So, what's going on in here?</p> <ol> <li>As before, we initialize our <code>PetEmployee</code> with a <code>name</code>, <code>species</code>, and <code>level</code>.</li> <li>Then, we define the <code>@property</code> for <code>email</code> and <code>fullname</code> which return a string representation of email and the full name of the pet respectively.</li> <li>We also have our <code>@fullname.setter</code> from earlier which allows us to set a new <code>name</code> and <code>species</code> for our pet.</li> <li>But here comes the new kid on the block, the <code>@fullname.deleter</code>. This piece of magic deletes the <code>name</code> and <code>species</code> of our pet, effectively sending them into oblivion, and prints a message saying, \"Delete Pet Name!\".</li> </ol> <p>Let's test it:</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 'Dog', 3)\ndel barkalot.fullname\nprint(barkalot.name) \nprint(barkalot.fullname) \nprint(barkalot.email)  \n</code></pre> Output<pre><code>Delete Pet Name!\nNone\nNone None\nNone.None@gmail.com\n</code></pre></p> <p>With a wave of our wand (well, the <code>del</code> command), we've gone ahead and removed our pet's name. Now, that's a power you'd want to handle carefully!</p> <p>And just like that, we've completed our trilogy of Python's getters, setters, and deleters! It's like we've just stepped out of a rollercoaster ride of Python object-oriented programming. But worry not, there are plenty more exciting rides in this amusement park. </p> <p>In our next adventure, how about we look at Python's built-in <code>property</code> function and how it can be used instead of the <code>@property</code> decorator? Or perhaps, we could delve into how Python's <code>getattr</code>, <code>setattr</code>, and <code>delattr</code> functions work. They provide another way to get, set, or delete attributes of an object. </p>"},{"location":"07_oop/#775-built-in-property-function","title":"7.7.5. Built-in property function","text":"<p>You've seen the <code>@property</code> decorator in action, now let's see how its sibling <code>property()</code> works its magic. Ready? Let's get coding!</p> <p>In Python, <code>property()</code> is a built-in function that creates and returns a property object. A property object has three methods, getter(), setter(), and deleter() that we can use instead of @property and its associated decorators. </p> <p>Let's put this into context with our beloved <code>PetEmployee</code> class. Instead of using <code>@property</code>, <code>@fullname.setter</code>, and <code>@fullname.deleter</code> decorators, we'll use the <code>property()</code> function:</p> Built-in property function<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself._name = name\nself._species = species\ndef get_fullname(self):\nreturn '{} {}'.format(self._name, self._species)\ndef set_fullname(self, name):\nfirst, last = name.split(' ')\nself._name = first\nself._species = last\ndef del_fullname(self):\nprint('Delete Pet Name!')\nself._name = None\nself._species = None\nfullname = property(get_fullname, set_fullname, del_fullname, \n\"I'm the 'fullname' property.\")\n</code></pre> <p>What just happened? Let's dissect this piece by piece:</p> <ol> <li> <p>We're defining our <code>get_fullname</code>, <code>set_fullname</code>, and <code>del_fullname</code> methods as usual. But notice that we're now working with <code>_name</code> and <code>_species</code>. These are called 'private' attributes, and it's a convention in Python to indicate that these attributes should not be accessed directly. They're meant to be manipulated through methods instead.</p> </li> <li> <p>Finally, the line <code>fullname = property(get_fullname, set_fullname, del_fullname, \"I'm the 'fullname' property.\")</code> creates the <code>fullname</code> property. The <code>property()</code> function takes four arguments: fget (getter function), fset (setter function), fdel (deleter function), and doc (docstring). We've set all of these for our <code>fullname</code> property.</p> </li> </ol> <p>Now let's test our new and shiny <code>PetEmployee</code>:</p> <p>Input<pre><code>barkalot = PetEmployee('Barkalot', 'Dog', 3)\nprint(barkalot.fullname)  # Output: Barkalot Dog\nbarkalot.fullname = 'Furrytail Cat'\nprint(barkalot.fullname)  # Output: Furrytail Cat\ndel barkalot.fullname  # Output: Delete Pet Name!\n</code></pre> Output<pre><code>Barkalot Dog\nFurrytail Cat\nDelete Pet Name!\n</code></pre></p> <p>With <code>property()</code>, we've gained another tool to effectively encapsulate data in our Python classes.</p> <p>In our next thrilling episode, we'll be exploring Python's <code>getattr()</code>, <code>setattr()</code>, and <code>delattr()</code> functions. These handy functions allow us to interact with an object's attributes using their string names! </p>"},{"location":"07_oop/#776-getattr-setattr-and-delattr","title":"7.7.6. getattr(), setattr(), and delattr()","text":"<p>The <code>getattr()</code> function is used to retrieve the value of a named attribute of an object. If not found, it returns the default value provided to the function.</p> <p>Input<pre><code>class PetEmployee:\ndef __init__(self, name, species, level):\nself.name = name\nself.species = species\nself.level = level\nbarkalot = PetEmployee('Barkalot', 'Dog', 3)\n# Using getattr()\nprint(getattr(barkalot, 'name'))  # Output: Barkalot\n</code></pre> Output<pre><code>Barkalot\n</code></pre></p> <p>The <code>setattr()</code> function is used to set the value of a named attribute of an object. If the attribute does not exist, this function creates a new attribute by the given name.</p> <p>Input<pre><code># Using setattr()\nsetattr(barkalot, 'name', 'Furrytail')\nprint(barkalot.name)  # Output: Furrytail\n</code></pre> Output<pre><code>Furrytail\n</code></pre></p> <p>The <code>delattr()</code> function is used to delete an attribute. If the attribute does not exist, this raises an <code>AttributeError</code>.</p> <p>Input<pre><code># Using delattr()\ndelattr(barkalot, 'name')\n# Now trying to access the name attribute will raise an AttributeError\nprint(barkalot.name) \n</code></pre> Output<pre><code>AttributeError: 'PetEmployee' object has no attribute 'name'\n</code></pre></p> <p>Error Handling</p> <p>Instead of raising an error, we can also use a <code>try</code>/<code>except</code> block to handle the error gracefully: Input<pre><code>try:\nprint(barkalot.name)\nexcept AttributeError:\nprint(\"'PetEmployee' object has no attribute 'name'\")\n</code></pre> Output<pre><code>'PetEmployee' object has no attribute 'name'\n</code></pre></p> <p>Seeing \"object has no attribute 'name'\" is Python's way of telling you that you've crossed a boundary and attempted to access something that just doesn't exist. It's like trying to walk through a door that isn't there. You're just going to run into a wall (or in our case, an error).</p> <p>These methods can be particularly useful in situations where you want to manipulate attributes dynamically, like in large projects or when working with user-defined inputs.</p> <p>Exercise</p> <p>Objective: </p> <p>Your task is to further enhance the Circle class in Python, making it aware of the unit system used (Metric or Imperial).</p> <p>Requirements:</p> <p>The Circle class currently supports a radius in centimeters (cm). However, we also want to accommodate input in inches for our friends who use the Imperial system. Enhance the Circle class to support initializing the radius in either cm or inches.</p> <p>Extend the radius setter method to convert an input radius in inches to cm before storing it in the _radius attribute. The unit attribute should control whether conversion takes place. If unit is 'inch', convert the input to cm (remember that 1 inch equals 2.54 cm). If unit is 'cm', store the input as is.</p> <p>Add a new property method, radius_inch, that returns the current radius converted to inches as a sanity check.</p> <p>Ensure that the area and circumference properties continue to work as expected, returning the area and circumference of the circle in cm\u00b2 and cm, respectively.</p> Code SkeletonSolution Input<pre><code>import math\nclass Circle:\ndef __init__(self, radius, unit='cm'):\nself.unit = unit\nself.radius = radius\n@property\ndef area(self):\npass\n@property\ndef circumference(self):\npass\n@property\ndef radius(self):\npass\n@radius.setter\ndef radius(self, radius):\npass\n@property\ndef radius_inch(self):\npass\ncircle_1 = Circle(3)\nprint(circle_1.radius) \nprint(circle_1.radius_inch)\ncircle_2 = Circle(4, 'inch') \nprint(circle_2.radius)\nprint(circle_2.radius_inch)\n</code></pre> Input<pre><code>import math\nclass Circle:\ndef __init__(self, radius, unit='cm'):\nself.unit = unit\nself.radius = radius  # Radius in specified unit\n@property\ndef area(self):\nreturn math.pi * self._radius**2\n@property\ndef circumference(self):\nreturn 2 * math.pi * self._radius\n@property\ndef radius(self):\nreturn self._radius\n@radius.setter\ndef radius(self, radius):\nif self.unit == 'inch':\nself._radius = radius * 2.54  # Convert from inch to cm\nelse:\nself._radius = radius\n@property\ndef radius_inch(self):\nreturn self._radius / 2.54  # Convert from cm to inch\ncircle_1 = Circle(3)  # Radius in cm\nprint(circle_1.radius)  # Output: 3\nprint(circle_1.radius_inch)  # Output: 1.1811 (3 cm in inches)\ncircle_2 = Circle(4, 'inch')  # Radius in inches\nprint(circle_2.radius)  # Output: 10.16 (4 inches in cm)\nprint(circle_2.radius_inch)  # Output: 4\n</code></pre> <p>In Python, we use the <code>@property</code> decorator to define <code>getter</code> methods. A <code>getter</code> method lets us access the value of a private attribute. Here, <code>radius</code> is a property of the class <code>Circle</code>, and the <code>radius</code> method gets the value of <code>_radius</code>.</p> <p>The <code>@radius.setter</code> decorator defines the setter method for the <code>radius</code> property. A setter method allows us to set or modify the value of a private attribute. In our case, the <code>radius</code> setter converts the given <code>radius</code> to centimeters if the provided unit is in inches.</p> <p>The <code>radius_inch</code> property allows us to convert and get the <code>radius</code> from centimeters to inches.</p> <p>In the code snippet above, we create two instances of the class <code>Circle</code>. For <code>circle_1</code>, we define the <code>radius</code> in centimeters, and for <code>circle_2</code>, we define the <code>radius</code> in inches. The code then demonstrates how these concepts can be applied to convert and print the <code>radius</code> in different units.</p>"},{"location":"08_errors/","title":"8. Error Handling and Exceptions","text":""},{"location":"08_errors/#81-motivation","title":"8.1. Motivation","text":"<p>Exception handling is a process of responding to the occurrence, during computation, of exceptions \u2013 anomalous or exceptional conditions requiring special processing \u2013 often changing the normal flow of program execution. It is provided by the software to handle an exception.</p> <p>Imagine this: you're feeling great, confidently coding away, when suddenly, you hit an error. You see a terrifying red message on your console: <code>[Errno 2] No such file or directory: 'test_.txt'</code>. Your code has crashed, and your app came to a screeching halt. This is the nightmare we all strive to avoid.</p> <p>Here's the offending line of code that brought upon this digital disaster:</p> Input<pre><code>f = open('test_.txt')\n</code></pre> Output<pre><code>[Errno 2] No such file or directory: 'test_.txt'\n</code></pre> <p>Seems innocent enough, right? You're just trying to open a file named <code>test_.txt</code>. But there lies the problem: What if the file doesn't exist? </p> <p>Well, that's exactly what's happened here. The file <code>test_.txt</code> doesn't exist in the directory, and Python, ever so literal, freaks out. It raises an error and stops the entire program.</p> <p>This situation can be quite distressing, especially if your code is running a mission-critical application. What if you're running an app that controls a hospital's life support systems, or an app that provides real-time navigation for drivers? An unexpected crash could have serious consequences. </p> <p>That's why error handling is so vital in programming. In Python, we have a powerful tool to catch and handle these errors: the <code>try/except</code> block. </p>"},{"location":"08_errors/#82-tryexcept-blocks","title":"8.2. Try/Except Blocks","text":"<p>Our seatbelt in this situation is the <code>try/except</code> block:</p> <p>Input<pre><code>try:\nf = open('test_.txt')  # We are trying to open the file here\nvar = not_exist_file  # Oops, this variable doesn't exist!\nexcept Exception:\nprint('Sorry. Wrong File Name')  # If an error happens in the try block, we catch it here and print a friendly message.\n</code></pre> Output<pre><code>Sorry. Wrong File Name\n</code></pre></p> <p>When our code hits the <code>try</code> block, it attempts to execute the code inside. If everything goes smoothly, it continues to run the rest of the code. But if it hits an error (like trying to access a non-existent file or variable), it jumps straight to the <code>except</code> block. The <code>Exception</code> keyword catches all types of errors, so no matter what went wrong in the <code>try</code> block, the <code>except</code> block will handle it gracefully.</p> <p>In our case, since the file 'test_.txt' doesn't exist and the variable <code>not_exist_file</code> is not defined, an error occurs. But rather than crashing our program, it triggers the <code>except</code> block, and we see the output: <code>'Sorry. Wrong File Name'</code>. The magic of try/except saves our day (or code)!</p> <p>Keep in mind that handling errors gracefully is an essential part of writing robust, production-ready code. With Python's try/except blocks, you're well-equipped to handle any bumps along the way. </p>"},{"location":"08_errors/#83-catching-specific-errors","title":"8.3. Catching Specific Errors","text":"<p>However, our <code>except</code> block was a bit too general. It catches all kinds of errors, not just the one we're anticipating (<code>FileNotFoundError</code>). </p> <p>We can specify which error our <code>except</code> block should catch. To do this, we simply follow the <code>except</code> keyword with the name of the error we're expecting. In our case, <code>FileNotFoundError</code>. If this specific error occurs, our <code>except</code> block will be executed:</p> <p>Input<pre><code>try:\nf = open('test.txt')\nvar = not_exist_file # this will throw an Nameerror.\nexcept FileNotFoundError:\nprint('Sorry. Wrong File Name')\n</code></pre> Output<pre><code>NameError: name 'not_exist_file' is not defined\n</code></pre></p> <p>But wait! There's more! If we run the code now, we're greeted with another error: <code>NameError: name 'not_exist_file' is not defined</code>. Our <code>try</code> block contains another error that we didn't catch. Remember, Python stops executing the <code>try</code> block as soon as it encounters an error. </p> <p>The plot thickens. Let's add another <code>except</code> block to catch this second error. Each <code>except</code> block will catch its specified error:</p> <p>Input<pre><code>try:\nf = open('test.txt')\nvar = not_exist_file # this will throw an error.\nexcept FileNotFoundError:\nprint('Sorry. Wrong File Name')\nexcept NameError:\nprint('Name not found in current scope.')\n</code></pre> Output<pre><code>Name not found in current scope.\n</code></pre></p> <p>Now our program runs without crashing, handling both errors gracefully, and our world is back in balance. So remember folks, always keep your exceptions specific. It's like inviting guests to a party. </p> <p>So far, we've seen how to catch specific errors using multiple <code>except</code> blocks. Now let's learn how to catch the error message itself.</p> <p>When an error occurs, Python creates an <code>exception object</code> that contains specific information about the error. We can grab this object and print its content to get a detailed error message. </p> <p>To do this, we'll add an <code>as e</code> after our exception in the <code>except</code> block. The <code>e</code> is just a variable name; you could call it anything, but <code>e</code> is common. This variable now holds the exception object. When we print <code>e</code>, we get the specific error message:</p> <p>Input<pre><code>try:\nf = open('test.txt')\nvar = not_exist_file # this will throw an error.\nexcept FileNotFoundError as e:\nprint(e)\nexcept NameError as e:\nprint(e)\n</code></pre> Output<pre><code>name 'not_exist_file' is not defined\n</code></pre></p> <p>This block of code will print: <code>name 'not_exist_file' is not defined</code> if the <code>NameError</code> is encountered. So instead of a vague \"Oops, something went wrong\", you get a detailed report of the error that occurred. </p> <p>This technique helps us debug our code by providing more specific information about what went wrong. </p>"},{"location":"08_errors/#84-else-and-finally-blocks","title":"8.4. <code>else</code> and <code>finally</code> Blocks","text":"<p>Now that we've gotten comfortable with using <code>try</code> and <code>except</code> to catch and handle exceptions, let's introduce two new blocks that can be used within the <code>try/except</code> structure: <code>else</code> and <code>finally</code>.</p> <p>The <code>else</code> block: </p> <p>The <code>else</code> block in <code>try/except</code> is used to specify a block of code to be executed if no exceptions were raised in the <code>try</code> block. In other words, if everything in the <code>try</code> block goes smoothly, the <code>else</code> block runs. It's kind of like saying, \"If there are no issues, then let's do this too!\" </p> <p>Here's how we used it in the code you provided:</p> <p>Input<pre><code>try:\nf = open('test.txt')\nexcept FileNotFoundError as e:\nprint(e)\nexcept Exception as e:\nprint(e)\nelse:\nprint(f.read())\nf.close()\n</code></pre> Output<pre><code>test!\n</code></pre></p> <p>In this code snippet, we attempt to open a file named 'test.txt'. If the file does not exist, a <code>FileNotFoundError</code> is raised and handled. If any other type of exception is raised, it's also caught and handled. If no exceptions are raised (meaning the file opens successfully), the <code>else</code> block is executed, and the file is read and then closed.</p> <p>The <code>finally</code> block:</p> <p>The <code>finally</code> block in <code>try/except</code> is a place to put any code that MUST execute, whether an exception was raised or not. It's like a safety net that catches any code you absolutely want to run, no matter what happens.</p> <p>Take a look at how we used it in the code:</p> <p>Input<pre><code>try:\nf = open('test.txt')\nexcept FileNotFoundError as e:\nprint(e)\nexcept Exception as e:\nprint(e)\nelse:\nprint(f.read())\nf.close()\nfinally:\nprint('Executing Finally...')\n</code></pre> Output<pre><code>test!\nExecuting Finally...\n</code></pre></p> <p>After trying to open the file, whether it succeeds or an exception occurs, 'Executing Finally...' is printed. This is because the <code>finally</code> block always executes, regardless of whether an exception occurred in the <code>try</code> block. </p> <p><code>finally</code> can be useful in many scenarios. For example, you might use it for cleanup tasks, such as closing files or network connections, regardless of the success or failure of the earlier operations. </p> <p>With the addition of <code>else</code> and <code>finally</code>, we now have a lot of control over how our program handles exceptions and ensures certain code always runs.</p>"},{"location":"08_errors/#85-raising-exceptions","title":"8.5. Raising Exceptions","text":"<p>In the above code, you used the <code>raise</code> keyword. The <code>raise</code> keyword is used to trigger an exception explicitly. We can also pass a custom message or another exception class with the <code>raise</code> keyword. Let's take a closer look at how you've used it:</p> <p>Input<pre><code>try:\nf = open('corrupt_.txt')\nif f.name == 'corrupt.txt':\nraise Exception\nexcept FileNotFoundError as e:\nprint(e)\nexcept Exception as e:\nprint('Error!')\nelse:\nprint(f.read())\nf.close()\nfinally:\nprint('Executing Finally...')\n</code></pre> Output<pre><code>[Errno 2] No such file or directory: 'corrupt_.txt'\nExecuting Finally...\n</code></pre></p> <p>In this case, you're attempting to open a file named <code>corrupt_.txt</code>. You then check if the file's name is <code>corrupt.txt</code>. If it is, you raise an Exception. If a <code>FileNotFoundError</code> occurs (i.e., if the file doesn't exist), it gets caught and you print out the error. If the raised Exception occurs, it also gets caught and you print out 'Error!'.</p> <p>In your specific case, the file <code>corrupt_.txt</code> does not exist. So, the <code>FileNotFoundError</code> is raised first and caught by the first <code>except</code> block. The error message is printed, and then the <code>finally</code> block is executed, printing 'Executing Finally...'.</p> <p>If the file had existed and its name was <code>corrupt.txt</code>, the <code>Exception</code> would be raised, 'Error!' would be printed, and the <code>finally</code> block would be executed.</p> <p>Let's say we want to raise an exception with a custom error message when the file name is 'corrupt.txt'. We can do this by passing a string to the <code>Exception</code> class, like so:</p> <p>Input<pre><code>try:\nf = open('corrupt.txt')\nif f.name == 'corrupt.txt':\nraise Exception('This is a corrupt file!')\nexcept FileNotFoundError as e:\nprint(e)\nexcept Exception as e:\nprint('Error!')\nelse:\nprint(f.read())\nf.close()\nfinally:\nprint('Executing Finally...')\n</code></pre> Output<pre><code>Error!\nExecuting Finally...\n</code></pre></p> <p>In this scenario, if the file <code>corrupt.txt</code> is found and opened successfully, an <code>Exception</code> is raised with the message 'Error!'. This exception is then caught by the second <code>except</code> block and the custom error message is printed. After that, the <code>finally</code> block is executed.</p> <p>Raising exceptions can be very useful when you want to enforce certain conditions in your code, and halt the execution if these conditions are not met.</p> <p>That wraps up this guide on Python's error handling and exceptions. By using <code>try/except</code> blocks, raising exceptions, and leveraging <code>else</code> and <code>finally</code> blocks, you can make your code more robust and able to handle unexpected errors more gracefully. </p>"}]}