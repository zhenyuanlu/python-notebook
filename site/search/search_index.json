{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Notebook from Zero to Advanced","text":"<p>Author: Zhenyuan Lu</p> <p>Version: 0.9.0</p> <p>Created: 12/05/2022, last modified on 5/10/2023</p> <p>Welcome to the Python Notebook from Zero to Advanced, an enjoyable place on the internet to learn Python (besides the best place official Python documentation, of course  )</p>"},{"location":"#about-this-book","title":"About This Book","text":"<p>This book is designed for those with little or no Python programming experience, and it is filled with concise, easy-to-understand examples that will help you learn quickly and effectively.</p> <p>Throughout this comprehensive guide, we'll cover a wide range of topics, including data types, control structures, functions, and more. </p>"},{"location":"00_disclaimer/","title":"Disclaimer","text":"<p>I am pretty sure there are some typing errors, spelling mistakes, and other inaccuracies. If you find any such issues, please do not hesitate to contact me via lu [dot] zhenyua [at] northeastern [dot] edu.</p> <p>This tutorial is aimed to those who have zero or less Python programming experience with concise and simple examples throughout the entire tutorial. The content has been inspired by official Python documentation, Corey Schafer's tutorial. If you believe any content has been used inappropriately, please let me know, and I will address the issue.</p> <p>This work is licensed under the MIT License.</p>"},{"location":"01_get_started/","title":"Get Started","text":"<p>Welcome! Python is a versatile and powerful programming language, widely used for web development, data analysis, artificial intelligence, and more. This tutorial will guide you through the installation of Python and setting up a Python development environment in PyCharm, a popular integrated development environment (IDE) for Python.</p> <p>To get started with Python, you'll first need to install it on your computer. Follow the instructions below for your operating system:</p>"},{"location":"01_get_started/#11-installation-with-anaconda","title":"1.1. Installation with Anaconda","text":"<p>Anaconda is a popular distribution of Python and R programming languages, which simplifies package management and deployment. It comes with many pre-installed packages and tools for data science and machine learning.</p> <p>For Windows:</p> <p>Visit the Anaconda website at https://www.anaconda.com/products/distribution and download the installer for your operating system. Run the installer and follow the installation instructions. After the installation is complete, you can verify the installation by opening a terminal (or Anaconda Prompt on Windows) and typing conda --version. You should see the installed Anaconda version displayed. To check the Python version, type <code>python --version</code>.</p> <p>For macOS:</p> <p>Visit the Anaconda website at https://www.anaconda.com/products/distribution and download the installer for macOS. Open the downloaded package (.pkg file) and follow the installation instructions. After the installation is complete, you can verify the installation by opening Terminal and typing conda --version. You should see the installed Anaconda version displayed. To check the Python version, type <code>python --version</code>.</p>"},{"location":"01_get_started/#12-standard-installation","title":"1.2. Standard Installation","text":"<p>For Windows:</p> <p>Visit the official Python website at https://www.python.org/downloads/ and download the latest version of Python. Run the installer. Be sure to check the box \"Add Python to PATH\" before clicking \"Install Now.\" This will make it easier to run Python from the command prompt. After the installation is complete, you can verify the installation by opening a command prompt and typing <code>python --version</code>. You should see the installed Python version displayed.</p> <p>For macOS:</p> <p>Visit the official Python website at https://www.python.org/downloads/ and download the latest version of Python. Open the downloaded package and follow the installation instructions. After the installation is complete, you can verify the installation by opening Terminal and typing <code>python --version</code>. You should see the installed Python version displayed.</p>"},{"location":"01_get_started/#12-setting-up-a-python-development-environment-in-pycharm","title":"1.2. Setting up a Python Development Environment in PyCharm","text":"<p>Now that Python is installed, let's set up a development environment in PyCharm.</p> <ol> <li> <p>Download and install PyCharm from https://www.jetbrains.com/pycharm/download/. There are two editions available: Community Edition (free) and Professional Edition (paid). For this tutorial, the Community Edition is sufficient.</p> </li> <li> <p>Open PyCharm and create a new project by clicking \"Create New Project\" on the welcome screen.</p> </li> <li> <p>Choose a location for your project and make sure the \"Python Interpreter\" field is set to the Python version you installed earlier. If not, click the gear icon next to the field and select \"Add Interpreter.\" Choose \"System Interpreter\" and select the Python executable from the list. Click \"Create\" to create your new Python project.</p> </li> <li> <p>You're now ready to start writing Python code! In the next chapter, we'll dive into Python basics, including syntax, variables, and data types.</p> </li> </ol>"},{"location":"02_data_types/","title":"2. Data Types","text":""},{"location":"02_data_types/#21-numbers","title":"2.1. Numbers","text":"<p>In this section, we will cover the different number types in Python, such as integers and floating-point numbers, and how to work with them.</p>"},{"location":"02_data_types/#211-integers-and-floats","title":"2.1.1. Integers and Floats","text":"<p>Python has two primary numeric types: integers (int) and floating-point numbers (float). </p> <p>Assign an integer <code>5</code> to a variable named <code>num</code>. The <code>print()</code> function is then used to output the value of <code>num</code> to the console.  Input<pre><code># Integers\nnum = 5\nprint(num)\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>Assign a floating-point number <code>5.2</code> to a variable named <code>num</code>. The <code>print()</code> function is then used to output the value of <code>num</code> to the console. Input<pre><code># Floats\nnum = 5.2\nprint(num)\n</code></pre> Output<pre><code>5.2\n</code></pre></p>"},{"location":"02_data_types/#212-type-and-__class__","title":"2.1.2. <code>type()</code> and <code>__class__</code>","text":"<p>Info</p> <p><code>type()</code> is a built-in function that returns the type of an object. It is the same as calling the object's <code>__class__</code> attribute, e.g. <code>object.__class__</code>, but which is less commonly used.</p> <p>Use <code>type()</code> to check the type of a variable. Input<pre><code>num = 5\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'int'&gt;\n</code></pre></p> <p>The num variable is a floating-point number, so the <code>type()</code> function returns <code>&lt;class 'float'&gt;</code>.</p> <p>Input<pre><code># Floats\nnum = 5.2\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'float'&gt;\n</code></pre></p> <p>Floats with scientific notation. Input<pre><code>num = 5.2e3\nprint(type(num))\n</code></pre> Output<pre><code>&lt;class 'float'&gt;\n</code></pre></p> <p>Use <code>__class__</code> to check the type of a variable.  Input<pre><code>print(num.__class__)\n</code></pre> Output<pre><code>&lt;class 'int'&gt;\n</code></pre></p>"},{"location":"02_data_types/#213-math-functions","title":"2.1.3. Math Functions","text":"<p>Python supports various mathematical operations that can be performed on numbers, such as addition, subtraction, multiplication, division, and more. Here's a list of common mathematical operations and their corresponding symbols:</p> <ul> <li>Addition: <code>+</code></li> <li>Subtraction: <code>-</code></li> <li>Multiplication: <code>*</code></li> <li>Division: <code>/</code></li> <li>Floor Division: <code>//</code></li> <li>Exponentiation: <code>**</code></li> <li>Modulus: <code>%</code></li> </ul> <p>Let's see some examples of using these mathematical operations:</p> AdditionSubtractionMultiplicationDivisionFloor DivisionExponentiationModulus <p>Input<pre><code>num = 5\nprint(num + 2)\n</code></pre> Output<pre><code>7\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num - 2)\n</code></pre> Output<pre><code>3\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num * 2)\n</code></pre> Output<pre><code>10\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num / 2)\n</code></pre> Output<pre><code>2.5\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num // 2)\n</code></pre> Output<pre><code>2\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num ** 2)\n</code></pre> Output<pre><code>25\n</code></pre></p> <p>Input<pre><code>num = 5\nprint(num % 2)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>These operations can be used in combination, following the standard order of operations (PEMDAS), to perform more complex calculations. Parentheses can be used to specify the order of operations explicitly.</p> <p><code>abs()</code> and <code>round()</code></p> <p><code>abs()</code> and <code>round()</code> are two built-in functions that can be used to perform mathematical operations on numbers. </p> <p>The <code>abs()</code> function returns the absolute value of a number.</p> <p>Input<pre><code># abs() function\nprint(abs(-5))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>The <code>round()</code> function rounds a number to a specified number of decimal places.</p> <p>Input<pre><code># round() function\nprint(round(5.75))\n</code></pre> Output<pre><code>6\n</code></pre></p> <p><code>round()</code> with 2nd argument to specify the number of decimal places. Here we round <code>5.75</code> to 1 decimal place.</p> <p>Input<pre><code># round() with 2nd argument\nprint(round(5.75, 1))\n</code></pre> Output<pre><code>5.8\n</code></pre></p>"},{"location":"02_data_types/#214-increment-and-decrement","title":"2.1.4. Increment and Decrement","text":"<p>In Python, you can increment or decrement the value of a variable using the <code>+=</code> and <code>-=</code> operators, respectively. These operators are shorthand for adding or subtracting a value to the variable and then assigning the result back to the variable.</p> <p>We use <code>num = num + 1</code> to increment the value of <code>num</code> by 1.  Input<pre><code># Increment\nnum = 5\nnum = num + 1\nprint(num)\n</code></pre> Output<pre><code>6\n</code></pre></p> <p>Increment using shorthand <code>+=</code> operator. The <code>+=</code> operator is equivalent to <code>num = num + 1</code>.</p> <p>Input<pre><code># Increment using shorthand +=\nnum = 5\nnum += 1\nprint(num)\n</code></pre> Output<pre><code>6\n</code></pre></p> <p>The <code>num = num - 1</code> is used to decrement the value of <code>num</code> by 1. Input<pre><code># Decrement\nnum = 5\nnum = num - 1\nprint(num)\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>Decrement using shorthand <code>-=</code> operator. The <code>-=</code> operator is equivalent to <code>num = num - 1</code>. Input<pre><code># Decrement using shorthand -=\nnum = 5\nnum -= 1\nprint(num)\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>Using the <code>+=</code> and <code>-=</code> operators can make your code shorter and more readable, especially when performing multiple increment or decrement operations on the same variable.</p>"},{"location":"02_data_types/#215-comparison-operators","title":"2.1.5. Comparison Operators","text":"<ul> <li>Equal: <code>==</code></li> <li>Not Equal: <code>!=</code></li> <li>Greater Than: <code>&gt;</code></li> <li>Less Than: <code>&lt;</code></li> <li>Greater or Equal: <code>&gt;=</code></li> <li>Less or Equal: <code>&lt;=</code></li> </ul> Setting<pre><code>num_1 = 5\nnum_2 = 2\n</code></pre> Equal: ==Not Equal: !=Greater Than: &gt;Less Than: &lt;Greater or Equal: &gt;=Less or Equal: &lt;= <p>Input<pre><code>print(num_1 == num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p> <p>Input<pre><code>print(num_1 != num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &gt; num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &lt; num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p> <p>Input<pre><code>print(num_1 &gt;= num_2)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Input<pre><code>print(num_1 &lt;= num_2)\n</code></pre> Output<pre><code>False\n</code></pre></p>"},{"location":"02_data_types/#216-casting","title":"2.1.6. Casting","text":"<p>Casting is the process of converting a value from one data type to another. In Python, casting is achieved using built-in functions like <code>int()</code>, <code>float()</code>, and <code>complex()</code>.</p> <p>For example, when working with numbers, you might need to convert a string to an integer or a float. This is useful when you want to perform mathematical operations on string representations of numbers.</p> <p><code>int()</code>: Convert a value to an integer <code>float()</code>: Convert a value to a float <code>complex()</code>: Convert a value to a complex number</p> <p>Check the type of variable <code>num_1</code>. </p> <p>Input<pre><code>num_1 = '5'\nprint(type(num_1))\n</code></pre> Output<pre><code>&lt;class 'str'&gt;\n</code></pre></p> <p>If we have two numbers as strings, when we <code>+</code> them, they are concatenated instead of added.</p> <p>Input<pre><code>num_1 = '5'\nnum_2 = '2'\nprint(num_1 + num_2)\n</code></pre> Output<pre><code>52\n</code></pre></p> <p>If we want to add them, we need to convert them to integers first.</p> <p>Input<pre><code># Convert string to int\nnum_1 = int(num_1)\nnum_2 = int(num_2)\nprint(num_1 + num_2)\n</code></pre> Output<pre><code>7\n</code></pre></p> <p>If we convert a floating number to an integer, the decimal part will be removed.</p> <p>Input<pre><code>num = 5.2\nprint(int(num))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>If we convert an integer to a float, the result will be a float with <code>.0</code> at the end.</p> <p>Input<pre><code># float()\nnum = 5\nprint(float(num))\n</code></pre> Output<pre><code>5.0\n</code></pre></p> <p>If we convert an integer to a complex number, the result will be a complex number with <code>j</code> at the end.</p> <p>Input<pre><code># complex()\nnum = 5\nprint(complex(num))\n</code></pre> Output<pre><code>(5+0j)\n</code></pre></p> <p><code>zfill()</code> method adds zeros (0) at the beginning of the string, until it reaches the specified length.</p> <p>Input<pre><code># zfill method\nnum = 5\nprint(str(num).zfill(3))\n</code></pre> Output<pre><code>005\n</code></pre></p>"},{"location":"02_data_types/#22-strings","title":"2.2. Strings","text":"<p>Strings are one of the most important and commonly used data types in Python. A string is simply a sequence of characters, such as letters, numbers, and symbols. In Python, strings are created using either single quotes <code>'&lt;str&gt;'</code> or double quotes <code>\"&lt;str&gt;\"</code>. This tutorial will cover the basics of string manipulation in Python, including string indexing, slicing, concatenation, formatting, and various string methods.</p> <p>A string variable named sentence is defined and assigned the value <code>\"Hello World\"</code>. The <code>print()</code> function is then used to output the value of sentence to the console. This code demonstrates how to create and output a basic string in Python. </p> <p>Input<pre><code>sentence = 'Hello World'\nprint(sentence)\n</code></pre> Output<pre><code>Hello World\n</code></pre></p>"},{"location":"02_data_types/#221-string-basics","title":"2.2.1. String Basics","text":"<p>Quotes</p> <p>Single quotes are faster, more readable, and more commonly used than double quotes in Python. However, if a string itself contains a single quote, then it must be escaped using a backslash \\ so that Python can properly interpret the string.</p> <p>In the example code, a new string variable named sentence is defined using single quotes and contains the word <code>\"Tub's World\"</code>. To escape the single quote in the middle of the string, a backslash is used before it. The <code>print()</code> function is then used to output the value of sentence to the console. </p> <p>Input<pre><code># Single quote\n# Use backslash to escape single quote\nsentence = 'Tub\\'s World'\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>The following is the same example as above, but using double quotes instead of single quotes. </p> <p>Input<pre><code># Use double quote\nsentence = \"Tub's World\"\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>Triple quotes are used to create multi-line strings. In the example code, a new string variable named sentence is defined using triple quotes and contains the string <code>\"Tub's World\"</code> and <code>\"is a good place to live in\"</code>. The <code>print()</code> function is then used to output the value of sentence to the console. </p> <p>Input<pre><code># Three double quotes for multi-line string\nsentence = \"\"\"Tub's World\nis a good place to live in\"\"\"\nprint(sentence)\n</code></pre> Output<pre><code>Tub's World\nis a good place to live in\n</code></pre></p> <p>Length of a String</p> <p>The following code demonstrates how to use the <code>len()</code> function to get the length of a string.</p> <p>Input<pre><code># Use len() to get the length of a string\nsentence = \"Tub's World\"\nprint(len(sentence))\n</code></pre> Output<pre><code>12\n</code></pre></p> <p>Upper and Lower Case</p> <p>The <code>lower()</code> method converts all the characters in a string to lowercase. This is useful for case-insensitive comparisons or normalization of text data.</p> <p>Input<pre><code># Lowercase (all letters)\nsentence = \"Tub's World\"\nprint(sentence.lower())\n</code></pre> Output<pre><code>tub's world\n</code></pre></p> <p>The <code>upper()</code> method converts all the characters in a string to uppercase.</p> <p>Input<pre><code># Uppercase (all letters)\nsentence = \"Tub's World\"\nprint(sentence.upper())\n</code></pre> Output<pre><code>TUB'S WORLD\n</code></pre></p> <p>Input<pre><code># Capitalize\nsentence = \"Tub's World\"\nprint(sentence.capitalize())\n</code></pre> Output<pre><code>Tub's world\n</code></pre></p> <p>The <code>capitalize()</code> method capitalizes the first character of a string and makes the rest of the characters lowercase.</p>"},{"location":"02_data_types/#222-string-indexing","title":"2.2.2. String Indexing","text":"<p>Indexing allows us to access individual characters within a string using their position, also known as the index. It is essential to understand that in Python, indexing starts from 0, meaning the first character in the string has an index of 0, the second character has an index of 1, and so on.</p> <p>Here, we define a string sentence containing the text <code>\"Tub's World\"</code>. We then use indexing to access the character at position 0, which is <code>'T'</code>. The <code>print()</code> function displays the output, confirming that the first character in the string is indeed <code>'T'</code>.</p> <p>Input<pre><code># String indexing\n# Indexing starts from 0\nsentence = \"Tub's World\"\nprint(sentence[0])\n</code></pre> Output<pre><code>T\n</code></pre></p> <p>Now, let's see how negative indexing works in Python:</p> <p>Input<pre><code># If index is negative, it starts from the end\nsentence = \"Tub's World\"\nprint(sentence[-1])\n</code></pre> Output<pre><code>d\n</code></pre></p> <p>Accessing an index that is out of range will result in an error. Input<pre><code># If we input 11, it will throw an error\nsentence = \"Tub's World\"\nprint(sentence[11])\n</code></pre> Output<pre><code>IndexError: string index out of range\n</code></pre></p>"},{"location":"02_data_types/#223-string-slicing","title":"2.2.3. String Slicing","text":"<p>String slicing is a technique used to extract a subset of characters from a string. Slicing is done by specifying the starting and ending indices of the slice, separated by a colon. The starting index is inclusive, and the ending index is exclusive. If either the starting or ending index is omitted, it defaults to the beginning or end of the string, respectively.</p> <p>Basic Indexing</p> <p>Input<pre><code># The first index is inclusive, the second index is exclusive\nsentence = \"Tub's World\"\n# Index: 012345678910\n# Reverse index: 9876543210\n</code></pre> Basic Syntax<pre><code># string[start:end:step]\nsentence = \"Tub's World\"\n# sentence[index:index:step]\n</code></pre></p> <p>Input<pre><code># The first index is inclusive, the second index is exclusive\nsentence = \"Tub's World\"\n# Index: 012345678910\nprint(sentence[0:3])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Input<pre><code># We can also omit the first index\nsentence = \"Tub's World\"\nprint(sentence[:3])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Input<pre><code># We can also omit the second index\nsentence = \"Tub's World\"\nprint(sentence[3:])\n</code></pre> Output<pre><code>'s World\n</code></pre></p> <p>Input<pre><code># We can also omit both index\nsentence = \"Tub's World\"\nprint(sentence[:])\n</code></pre> Output<pre><code>Tub's World\n</code></pre></p> <p>Reverse Slicing</p> <p>If we want to print out the <code>World</code>, we can use reverse indexing to get the last 5 characters: Input<pre><code>sentence = \"Tub's World\"\n# Reverse index: 9876543210\nprint(sentence[-6:-1])\n</code></pre> Output<pre><code>World\n</code></pre></p> <p>Step Size</p> <p>We can also specify a step size to skip characters in the string. The following code demonstrates how to use a step size of 2 to print out every other character in the string:</p> <p>Input<pre><code># Step size\nsentence = \"Tub's World\"\nprint(sentence[::2])\n</code></pre> Output<pre><code>Tb sWrd\n</code></pre></p> <p>We can also specify a step size of 2 to print out every other character in the string, starting from the second character to the : Input<pre><code># Step size\nsentence = \"Tub's World\"\nprint(sentence[1:6:2])\n</code></pre> Output<pre><code>u'\n</code></pre></p> <p>Negative Step Size</p> <p>We can also use a negative step size to reverse the string:</p> <p>Input<pre><code># Negative step size\nsentence = \"Tub's World\"\nprint(sentence[::-1])\n</code></pre> Output<pre><code>dlroW s'buT\n</code></pre></p> <p>We can also print out the same result by using the following code:</p> <p>Input<pre><code>sentence = \"Tub's World\"\nprint(sentence[-1:2:-1])\n</code></pre> Output<pre><code>dlroW s'buT\n</code></pre></p>"},{"location":"02_data_types/#224-count-find-and-replace","title":"2.2.4. <code>count()</code>, <code>find()</code>, and <code>replace()</code>","text":"<p>The <code>count()</code>, <code>find()</code>, and <code>replace()</code> methods are used to count, find, and replace substrings within a string, respectively.</p> <p><code>count()</code> returns the number of occurrences of a specified substring in the given string.</p> <p>Input<pre><code># Count (return the number of occurrences)\nsentence = \"Tub's World\"\nprint(sentence.count('o'))\n</code></pre> Output<pre><code>1\n</code></pre></p> <p><code>find()</code> returns the index of the first occurrence of a specified substring in the given string.</p> <p>Input<pre><code># Find (return the index of the first occurrence)\nsentence = \"Tub's World\"\nprint(sentence.find('o'))\n</code></pre> Output<pre><code>8\n</code></pre></p> <p><code>replace()</code> replaces all occurrences of a specified substring (old) with a new substring in the given string.</p> <p>Input<pre><code># Replace (replace old with new)\nsentence = \"Tub's World\"\nprint(sentence.replace('Tub', 'Tom'))\n</code></pre> Output<pre><code>Tom's World\n</code></pre></p> <p>We can also assign the result of the replace() method back to the same variable if we want to update the original string: Input<pre><code># We can also assign the result to the same variable\nsentence = \"Tub's World\"\nsentence = sentence.replace('Tub', 'Tom')\nprint(sentence)\n</code></pre> Output<pre><code>Tom's World\n</code></pre></p>"},{"location":"02_data_types/#225-string-concatenation","title":"2.2.5. String Concatenation","text":"<p>String concatenation is a technique used to join two or more strings together. In Python, string concatenation is done using the <code>+</code> operator.</p> <p>Input<pre><code># String concatenation\nname = 'Tub'\nage = 5\nsentence = name + 'is' + str(age) + 'years old'\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>String concatenation is essential when working with dynamic content, such as user input or data from external sources, as it enables you to construct meaningful and contextually relevant strings. When concatenating strings, it's essential to pay attention to spaces and punctuation to ensure the resulting string is formatted correctly. For instance, in this example, we've added a space character between the punctuation and noun variables to separate the words in the final string.</p>"},{"location":"02_data_types/#226-string-formatting","title":"2.2.6. String Formatting","text":"<p>String formatting is a technique used to embed values within a string. In Python, there are several ways to format strings, including using the <code>format()</code> method and using f-strings. The <code>format()</code> method allows you to embed values within a string using placeholders, which are represented by curly braces <code>{}</code>. You can also use named placeholders to improve the readability of your code. F-strings are a more recent addition to Python and provide a more concise and intuitive way to embed values within a string.</p> <p>Here, we have three string variables: <code>name</code>, and an integer variable <code>age</code>. We introduce three methods for including non-string variables in a string using string formatting:</p> <p>Input: Setting up variables<pre><code># If we want to concatenate a lot of strings, \n# it is better to use string formatting\nname = 'Tub'\nage = 5\n</code></pre> Method 1: Using the <code>format()</code> method Input<pre><code># Method 1\n# Use format() method\nsentence = '{} is {} years old'.format(name, age)\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>Method 2: Using the <code>format()</code> method with keyword arguments Input<pre><code># Method 2\n# use format() method with keyword arguments\nsentence = '{n} is {a} years old'.format(n=name, a=age)\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>Method 3: Using <code>f</code>-strings (Python 3.6+) Input<pre><code># Method 3\n# Use f-string (3.6+)\nsentence = f'{name} is {age} years old'\nprint(sentence)\n</code></pre> Output<pre><code>Tub is 5 years old\n</code></pre></p> <p>In addition to the methods above, we can also modify the string content within the string formatting. In this case, we convert the name variable to uppercase using the <code>.upper()</code> method:</p> <p>Input<pre><code># With upper case\nsentence = f'{name.upper()} is {age} years old'\nprint(sentence)\n</code></pre> Output<pre><code>TUB is 5 years old\n</code></pre></p> <p>All three methods allow you to easily include non-string variables in your string, without the need for explicit type conversion, making them more efficient and readable than traditional string concatenation.</p>"},{"location":"02_data_types/#227-dir-and-help","title":"2.2.7. <code>dir()</code> and <code>help()</code>","text":"<p>The <code>dir()</code> function returns a list of all attributes and methods of the specified object, while the <code>help()</code> function provides documentation on a specific attribute or method.</p> <p>We pass the name variable, which is a string, to the dir() function. This will return a list of all available attributes and methods for the string object.</p> <p>Input<pre><code># dir() function returns a list of all \n# attributes and methods of the specified object\nname = 'Tub'\nprint(dir(name))\n</code></pre> Output<pre><code>['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__',\n '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__',\n '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__',\n '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',\n '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find',\n 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower',\n 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans',\n 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',\n 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n</code></pre></p> <p>We can also use <code>help()</code> function to display information about the string variable, but instead of passing the variable name, we pass the string object <code>str</code> itself. </p> <p>Input<pre><code># help() function\nname = 'Tub'\nprint(help(str))\n</code></pre> Output (partial)<pre><code>Help on class str in module builtins:...\n...\n</code></pre></p>"},{"location":"02_data_types/#23-lists","title":"2.3. Lists","text":"<p>Lists in Python are ordered, mutable collections of items. They can store elements of different types, such as strings, integers, or other objects.</p> <p>Creating a list with pet names:</p> <p>Input<pre><code># A list of pets names\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>Create an empty list using the <code>[]</code> or <code>list()</code> function: Input<pre><code># Create empty list\nempty_list = []\n# or\nempty_list = list()\nprint(empty_list)\n</code></pre> Output<pre><code>[]\n</code></pre></p>"},{"location":"02_data_types/#231-list-indexing","title":"2.3.1. List Indexing","text":"<p>Check the length of the list using the <code>len()</code> function: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(len(pet))\n</code></pre> Output<pre><code>4\n</code></pre></p> <p>In Python the first element of a list has index <code>0</code>, which is different from other programming languages, e.g. R, where the first element has index <code>1</code>.</p> <p>Access the first element of the list using the index <code>0</code>:</p> <p>Input<pre><code># Indexing starts from 0\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[0])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>Access the last element of the list using the index <code>-1</code>: Input<pre><code># If index is negative, it starts from the end\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[-1])\n</code></pre> Output<pre><code>Barkalot\n</code></pre></p> <p>Access the second element of the list using the index <code>1</code>: Input<pre><code>```python title=\"Input\"\n# If we input 4, it will throw an error\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[4])\n</code></pre> Output<pre><code>IndexError: list index out of range\n</code></pre></p>"},{"location":"02_data_types/#232-list-slicing","title":"2.3.2. List Slicing","text":"<p>Slicing is a way to access a subset of a list. We can use the colon <code>:</code> to specify the start and end index of the slice. The slice will include the start index, but not the end index.</p> <p>Basic Indexing for List Slicing</p> Basic Indexing<pre><code># Index: 0  1  2  3\n# Reverse index : -4 -3 -2 -1\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre> Basic Syntax<pre><code># list[start:end:step]\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\n# pet[index:index:step]\n</code></pre> <p>Slice the first two elements of the list: Input<pre><code># Slicing starts from 0\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[0:2])\n</code></pre> Output<pre><code>['Tub', 'Furrytail']\n</code></pre></p> <p>If we omit the start index, the slice will start from the beginning of the list: Input<pre><code># Omit the first index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[:2])\n</code></pre> Output<pre><code>['Tub', 'Furrytail']\n</code></pre></p> <p>If we omit the end index, the slice will end at the end of the list: Input<pre><code># Omit the second index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[2:])\n</code></pre> Output<pre><code>['Cat', 'Barkalot']\n</code></pre></p> <p>We can also omit both indices to return the entire list: Input<pre><code># Omit both index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet[:])\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>Reverse Slicing Recall that the index <code>-1</code> refers to the last element of the list. We can use this to reverse the list: Input<pre><code># Reverse Index: -5, -4, -3, -2, -1\nnumbers_list = [1, 2, 3, 4, 5]\nprint(numbers_list[-3:-1])\n</code></pre> Output<pre><code>[3, 4]\n</code></pre></p> <p>If we want to all the way from the last element to the <code>-3</code> index (not including the <code>-3</code> index), we can omit the last index: Input<pre><code>print(numbers_list[-3:])\n</code></pre> Output<pre><code>[3, 4, 5]\n</code></pre></p> <p>Or we can omit the first index to all the way from the first element to the <code>-3</code> index (not including the <code>-3</code> index): Input<pre><code>print(numbers_list[:-3])\n</code></pre> Output<pre><code>[1, 2]\n</code></pre></p> <p>We can also use positive step size to reverse the list: Input<pre><code>print(numbers_list[1:-2])\n</code></pre> Output<pre><code>[2, 3]\n</code></pre></p> <p>Step Size</p> <p>We can also specify the step size of the slice. For example, we can slice every other element of the list by specifying the step size as <code>2</code>: Input<pre><code>```python title=\"Input\"\nnumbers_list = [1, 2, 3, 4, 5]\n# list[start:end:step]\nprint(numbers_list[0:3:2])\n</code></pre> Output<pre><code>[1, 3]\n</code></pre></p> <p>The default step size is <code>1</code>. We can omit the step size if we want to slice every element of the list:</p> <p>Omit the step size: Input<pre><code>print(numbers_list[0:3])\n</code></pre> Output<pre><code>[1, 2, 3]\n</code></pre></p> <p>With step size <code>1</code>: Input<pre><code>print(numbers_list[0:3:1])\n</code></pre> Output<pre><code>[1, 2, 3]\n</code></pre></p> <p>We can also use negative step size to reverse the list: Input<pre><code>print(numbers_list[0:3:-1])\n</code></pre> Output<pre><code>[]\n</code></pre> However, this will return an empty list. Since the step size is negative number <code>-1</code>, the slice will start from the <code>0</code> index and then move backward to the <code>-1</code> index, which is on the opposite direction of index <code>3</code>. Therefore, it returns an empty list.</p> <p>To fix this, we can reverse the start and end index: Input<pre><code>print(numbers_list[-3::-1])\n</code></pre> Output<pre><code>[3, 2, 1]\n</code></pre></p> <p>We can also omit the start and end index to include the entire list, by a step of <code>-2</code>: Input<pre><code>print(numbers_list[::-2])\n</code></pre> Output<pre><code>[5, 3, 1]\n</code></pre></p>"},{"location":"02_data_types/#232-list-methods","title":"2.3.2. List Methods","text":"<p>There are many methods that can be used with lists. In the following examples, we will introduce couple of common methods to manipulate the list. </p> <p>Add an item to the end of the list using the <code>append()</code> method: Input<pre><code># Add an item to the end of the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.append('Hootsworth ')\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Hootsworth ']\n</code></pre></p> <p>Add an item to a specific index, e.g. <code>2</code>, using the <code>insert()</code> method: Input<pre><code># Add an item to a specific index\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.insert(2, 'Fish')\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Fish', 'Cat', 'Barkalot']\n</code></pre></p> <p>Now, we want to insert a list into a list after a specific location, e.g. 0, using the <code>insert()</code> method: Input<pre><code># Insert a list into a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = ['Bumblefluff ', 'Whiskerfloof']\npet.insert(0, pet_2)\nprint(pet)\n</code></pre> Output<pre><code>[['Bumblefluff ', 'Whiskerfloof'], 'Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p><code>insert()</code> method inserts the list as a single element</p> <p>However, this is not what we want because we want to insert the elements of the list <code>pet_2</code> into the list <code>pet</code>. </p> <p>Then we can use the <code>extend()</code> instead to do this: Input<pre><code># Extend a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = ['Bumblefluff ', 'Whiskerfloof']\npet.extend(pet_2)\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot', 'Bumblefluff ', 'Whiskerfloof']\n</code></pre> Now, we have successfully inserted the elements of the list <code>pet_2</code> into the list <code>pet</code>.</p> <p>We can remove an item from the list using the <code>remove()</code> method: Input<pre><code># Remove an item from the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.remove('Tub')\nprint(pet)\n</code></pre> Output<pre><code>['Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>We can also remove an item from the list using the <code>pop()</code> method. If we do not specify the index, it will remove the last item from the list: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.pop()\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat']\n</code></pre></p> <p>Or we can specify the index to remove the item at that index: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.pop(1)\nprint(pet)\n</code></pre> Output<pre><code>['Tub', 'Cat', 'Barkalot']\n</code></pre></p> <p>We can also use the <code>pop()</code> method to get the item that we removed from the list, and assign it to the <code>popped_sp</code> variable: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npopped_pet = pet.pop()\nprint(popped_pet)\n</code></pre> Output<pre><code>Barkalot\n</code></pre> This is very helpful when we have a queue to keep popping until the queue is empty and we want to keep track of the items that we have popped.</p> <p>If we want to search for an index of an item in the list, we can use the <code>index()</code> method: Input<pre><code># Search for an index of an item in the list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nprint(pet.index('Tub'))\n</code></pre> Output<pre><code>0\n</code></pre></p> <p>We can check if the <code>'Tub'</code> is in the pet list using the <code>in</code> keyword: Input<pre><code># If an item is in the list\nprint('Tub' in pet)\n</code></pre> Output<pre><code>True\n</code></pre></p> <p>Sometimes, we want to join a list of strings into a single string. We can use the <code>join()</code> method to do this: Input<pre><code># Join a list of strings\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_str = ','.join(pet)\nprint(pet_str)\n</code></pre> Output<pre><code>Tub,Furrytail,Cat,Barkalot\n</code></pre></p> <p>Or we can split the single string into a list by a specific character, e.g. <code>,</code>: Input<pre><code># Split a string into a list by ','\npet_str = 'Tub,Furrytail,Cat,Barkalot'\npet_list = pet_str.split(',')\nprint(pet_list)\n</code></pre> Output<pre><code>['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre></p> <p>When dealing with a list of numbers, we can use the <code>min()</code>, <code>max()</code>, and <code>sum()</code> functions to get the minimum, maximum, and sum of the numbers in the list:</p> <code>min()</code><code>max()</code><code>sum()</code> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(min(nums))\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(max(nums))\n</code></pre> Output<pre><code>5\n</code></pre></p> <p>Input<pre><code>nums = [5, 3, 2, 4, 1]\nprint(sum(nums))\n</code></pre> Output<pre><code>15\n</code></pre></p>"},{"location":"02_data_types/#233-sorting-and-reversing","title":"2.3.3. Sorting and Reversing","text":"<p>We can reverse a list of strings using the <code>reverse()</code> method in reverse alphabetical order: Input<pre><code># Reverse a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.reverse()\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub']\n</code></pre></p> <p>We can sort a list of strings using the <code>sort()</code> method in alphabetical order: Input<pre><code># Sort a list\npet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet.sort()\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub']\n</code></pre></p> <p>We can sort a list of numbers using the <code>sort()</code> method in alphabetical order: Input<pre><code>nums = [5, 3, 2, 4, 1]\nnums.sort()\nprint(nums)\n</code></pre> Output<pre><code>[1, 2, 3, 4, 5]\n</code></pre></p> <p>Of course, we can also sort a list of numbers in reverse order by using <code>sort(reverse = True)</code>: Input<pre><code># Instead of using .reverse(), we can use reverse = True\nnums.sort(reverse = True)\nprint(nums)\n</code></pre> Output<pre><code>[5, 4, 3, 2, 1]\n</code></pre></p> <p>However, the above methods <code>sort()</code> and <code>reverse()</code> are changing our original variables. What if we want to keep the original variables? We can use the <code>sorted()</code> function to sort a list of strings in alphabetical order: Input<pre><code>pet = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nsorted_pet = sorted(pet)\nprint(sorted_pet)\nprint(pet)\n</code></pre> Output<pre><code>['Barkalot', 'Cat', 'Furrytail', 'Tub'] # sorted_pet\n['Tub', 'Furrytail', 'Cat', 'Barkalot'] # original pet\n</code></pre> Here, we don't change the original variable <code>pet</code> but create a new variable <code>sorted_pet</code> to store the sorted list. This is useful when we want to keep the original list unchanged.</p>"},{"location":"02_data_types/#24-tuples","title":"2.4. Tuples","text":"<p>Tuples are similar to lists, but they are immutable. This means that we cannot change the contents of a tuple once it is created. Tuples are useful when we want to store a list of items that cannot be changed. </p>"},{"location":"02_data_types/#241-creating-a-tuple","title":"2.4.1. Creating a Tuple","text":"<p>Create an empty tuple is similar to creating an empty list, the only difference is that we use <code>()</code> instead of <code>[]</code>, or you can use the <code>tuple()</code> function: Input<pre><code># Create empty tuple\nempty_tuple = ()\n# or\nempty_tuple = tuple()\nprint(empty_tuple)\n</code></pre> Output<pre><code>()\n</code></pre></p> <p>Create a tuple based on the same strings as the list <code>pet</code>: Input<pre><code>pet_tup_1 = ('Tub', 'Furrytail', 'Cat', 'Barkalot')\nprint(pet_tup_1)\n</code></pre> Output<pre><code>('Tub', 'Furrytail', 'Cat', 'Barkalot')\n</code></pre></p>"},{"location":"02_data_types/#25-immutable-vs-mutable","title":"2.5. Immutable vs. Mutable","text":"<p>Immutable means that we cannot change the contents of the object. Mutable means that we can change the contents of the object. </p> <p>Here's a general overview of the advantages and disadvantages of mutable and immutable objects:</p> <p>Pros and Cons of Immutable</p> Pros of ImmutableCons of Immutable <p>Note</p> <p>Simplicity: Immutability makes the code easier to reason about, as you don't have to worry about unintentional changes to the object.</p> <p>Hashable: Immutable objects can be used as keys in dictionaries, as their content remains constant and their hash values do not change over time.</p> <p>Optimization: Immutable objects allow languages and compilers to perform certain optimizations that can improve the performance of a program.</p> <p>Thread-safety: Immutable objects are inherently thread-safe, as multiple threads cannot modify them simultaneously. This property eliminates the need for locking mechanisms when working with immutable objects in multi-threaded environments.</p> <p>Predictability: When you pass an immutable object to a function, you can be sure that the function will not modify the object, which ensures that the behavior of the program remains predictable.</p> <p>Note</p> <p>Memory overhead: Since each operation on an immutable object creates a new object, it can lead to increased memory usage, especially when manipulating large objects or performing many operations.</p> <p>Performance: Creating new objects for each operation can be slower than modifying objects in-place, particularly in cases where the program performs many operations on objects. In such situations, using mutable data structures may be more efficient.</p> <p>Pros and Cons of Mutable</p> Pros of MutableCons of Mutable <p>Note</p> <p>In-place modification: Mutable objects can be modified in-place, which can lead to better performance and lower memory usage, especially when working with large objects or performing many operations on objects.</p> <p>Flexibility: Mutable objects offer more flexibility in how you can manipulate and change data, which can be helpful in certain scenarios.</p> <p>Note</p> <p>Complexity: Mutable objects can make code harder to reason about, as you need to consider the possibility of unintentional changes to the object.</p> <p>Thread-safety: Mutable objects are not inherently thread-safe, and using them in multi-threaded environments can lead to race conditions and other concurrency-related issues if proper locking mechanisms are not in place.</p> <p>Predictability: When you pass a mutable object to a function, you cannot be sure whether the function will modify the object or not, which can make the behavior of the program less predictable.</p> <p>Not hashable: Mutable objects cannot be used as keys in dictionaries, as their content can change, potentially causing issues with hashing.</p>"},{"location":"02_data_types/#251-string-is-immutable","title":"2.5.1. String is Immutable","text":"<p>Strings in Python are immutable, meaning you cannot change their content directly. Instead, when you perform operations like concatenation, replacement, changing the case, or slicing, you create new strings rather than modifying the original ones.</p> <p>Concatenation</p> <p>Input<pre><code>original_string = \"Hello, \"\npet = \"Tub\"\ngreeting = original_string + pet\nprint(greeting)\nprint('Address of original_string is: {}'.format(id(original_string)))\nprint('Address of greeting is: {}'.format(id(greeting)))\n</code></pre> Output<pre><code>Hello, Tub  \nAddress of original_string is: 2186723937904\nAddress of greeting is: 2186728523312\n</code></pre> As you can see, the memory addresses of the original string and the new string are different, confirming that a new string is created during concatenation.</p> <p>Replace</p> <p>The replace() method in Python is used to replace a specified value with another value in a string. When you use the <code>replace()</code> method, a new string is created, and the original string remains unchanged.</p> <p>Input<pre><code>original_string = \"Hello, World!\"\nnew_string = original_string.replace(\"World\", \"Tub\")\nprint(new_string)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of new_string is:{}'.format(id(new_string)))\n</code></pre> Output<pre><code>Hello, Tub\nAddress of original_string is:1436882337200\nAddress of new_string is:1436885468848\n</code></pre> Again, the memory addresses of the original string and the new string are different, confirming that a new string is created during the replacement.</p> <p>Change the Case</p> <p>Input<pre><code>original_string = \"Tub is awesome!\"\nuppercase_string = original_string.upper()\nprint(uppercase_string)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of uppercase_string is:{}'.format((id(uppercase_string))))\n</code></pre> Output<pre><code>TUB IS AWESOME!\nAddress of original_string is:1923265193776\nAddress of uppercase_string is:1923268233008\n</code></pre> Again, the memory addresses of the original string and the new string are different.</p> <p>Then you may ask what is the advantage of immutable: </p> <p>Slicing When you slice a string, a new string is created, and the original string remains unchanged.</p> <p>Input<pre><code>original_string = \"Tub is cute!\"\nsubstring = original_string[0:3]\nprint(substring)\nprint('Address of original_string is:{}'.format(id(original_string)))\nprint('Address of substring is:{}'.format(id(substring)))\n</code></pre> Output<pre><code>Tub\nAddress of original_string is:1923265193776\nAddress of substring is:1923268233008\n</code></pre></p>"},{"location":"02_data_types/#251-list-is-mutable","title":"2.5.1. List is Mutable","text":"<p>Input<pre><code>pet_1 = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = pet_1\npet_1[1] = 'Furrytail 2'\nprint(pet_1)\nprint(pet_2)\n</code></pre> Output<pre><code>['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n</code></pre> We can see that when we change the contents of <code>pet_1</code>, the contents of <code>pet_2</code> also change. This is because <code>pet_1</code> and <code>pet_2</code> are both references to the same list in memory.</p> <p>Input<pre><code>print('Address of pet_1 is: {}'.format(id(pet_1)))\nprint('Address of pet_2 is: {}'.format(id(pet_2)))\n</code></pre> Output<pre><code>Address of pet_1 is: 2250825683136\nAddress of pet_2 is: 2250825683136\n</code></pre> The address of <code>pet_1</code> and <code>pet_2</code> are the same, which means they are both references to the same list in memory.</p> <p>Python vs. R in Variable Assignment</p> <p>Python and R handle variable assignment differently, particularly when it comes to mutable objects like lists in Python.</p> <p>In R, when you assign one variable to another, it creates a copy of the original variable's data. This means that if you change one variable's contents, the other variable's contents remain unchanged. This behavior is known as \"copy-on-write\" and allows R to save memory by not duplicating data until it is necessary.</p> <p>In Python, when you assign one variable to another, you are actually creating a reference to the original variable's data, rather than copying the data itself. This means that if you change the contents of one variable, the other variable's contents will also change because they both point to the same data in memory.</p> <p>If you want to create a new list that is a copy of <code>pet_1</code> like that in R and not a reference to <code>pet_1</code>, you can use the <code>copy()</code> method: Input<pre><code>pet_1 = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\npet_2 = pet_1.copy()\npet_1[1] = 'Furrytail 2'\nprint(pet_1)\nprint(pet_2)\n</code></pre> Output<pre><code>['Tub', 'Furrytail 2', 'Cat', 'Barkalot']\n['Tub', 'Furrytail', 'Cat', 'Barkalot']\n</code></pre> We can see that when we change the contents of <code>pet_1</code>, the <code>pet_2</code> remain unchanged. This is because <code>pet_2</code> refers to a new list that is a copy of <code>pet_1</code>.</p> <p>Input<pre><code>print('Address of pet_1 is: {}'.format(id(pet_1)))\nprint('Address of pet_2 is: {}'.format(id(pet_2)))\n</code></pre> Output<pre><code>Address of pet_1 is: 1704413046016\nAddress of pet_2 is: 1704413120128\n</code></pre> The address of <code>pet_1</code> and <code>pet_2</code> are different.</p>"},{"location":"02_data_types/#252-tuple-is-immutable","title":"2.5.2. Tuple is Immutable","text":"<p>In the other hand, tuple is immutable, so we cannot change the contents of a tuple once it is created. For example, we cannot change the second item <code>Furrytail</code> in the tuple <code>pet_tup_1</code>: Input<pre><code># Immutable\npet_tup_1 = ('Tub', 'Furrytail', 'Cat', 'Barkalot')\npet_tup_1[1] = 'Furrytail 2'\nprint(pet_tup_1)\n</code></pre> Output<pre><code>TypeError: 'tuple' object does not support item assignment\n</code></pre> Here we get an error message <code>TypeError: 'tuple' object does not support item assignment</code> on changing the second item in the <code>pet_tup_1</code> tuple.</p>"},{"location":"02_data_types/#26-dictionaries","title":"2.6. Dictionaries","text":"<p>Dictionaries are similar to lists, but instead of using an index to access an item, we use a key. Dictionaries are unordered, and we cannot sort them. Dictionaries are mutable, so we can change the contents of a dictionary once it is created.</p>"},{"location":"02_data_types/#261-creating-a-dictionary","title":"2.6.1. Creating a Dictionary","text":"<p>Let's create a dictionary that stores one of our old friend <code>'Tub'</code>, its <code>age</code>, and favoriate <code>habitat</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p>"},{"location":"02_data_types/#262-accessing-items-in-a-dictionary","title":"2.6.2. Accessing Items in a Dictionary","text":"<p>We can access the items in a dictionary by using the key <code>'species'</code>, <code>'age'</code>, and <code>'habitat'</code>: Input<pre><code>print(pet['species'])\nprint(pet['age'])\nprint(pet['habitat'])\n</code></pre> Output<pre><code>Tub\n5\n['bathroom', 'kitchen']\n</code></pre></p> <p>Of course, we can use number as the key, but it is not recommended: Input<pre><code>pet = {1: 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet[1])\n</code></pre> Output<pre><code>Tub\n</code></pre></p> <p>What if we accidently acces a key that not exist in the dictionary? Input<pre><code># Access a key that not exist\npet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet['weight'])\n</code></pre> Output<pre><code>KeyError: 'weight'\n</code></pre> We will get an error message <code>KeyError: 'weight'</code>. </p> <p>But practically this is not ideal, sometimes we just want to check if the key is in the dictionary or not without showing error, but return a <code>flag</code>. </p> <p>We can use <code>get()</code> method to do this: Input<pre><code># Get method\npet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.get('age'))\nprint(pet.get('weight'))\n</code></pre> Output<pre><code>5\nNone\n</code></pre> We can see that when we use <code>get()</code> method, if the key is in the dictionary, it will return the value of the key, e.g. <code>5</code>, but if the key is not in the dictionary, it will return <code>None</code>.</p> <p>We can also specify a default value to return if the key is not in the dictionary instead of <code>None</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.get('weight', 'Not there'))\n</code></pre> Output<pre><code>Not there\n</code></pre></p>"},{"location":"02_data_types/#263-changing-items-in-a-dictionary","title":"2.6.3. Changing Items in a Dictionary","text":"<p>We can update the value of a key, e.g. <code>'weight'</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet['weight'] = 2000\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen'], 'weight': 2000}\n</code></pre></p> <p>We can also use <code>update()</code> to update the values from keys in a dictionary: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet.update({'weight': 1000, 'name': 'Fluffy', 'age': 6})\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'age': 6, 'habitat': ['bathroom', 'kitchen'], 'weight': 1000, 'name': 'Fluffy'}\n</code></pre></p> <p>While if we want to delete the key <code>'age'</code> and its value from the dictionary, we can use <code>del</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\ndel pet['age']\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p> <p>Or use <code>pop()</code>:  Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\npet.pop('age')\nprint(pet)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n</code></pre></p> <p>We can also assign the popped value to a variable: Input<pre><code>popped_age = pet.pop('age')\nprint(pet)\nprint(popped_age)\n</code></pre> Output<pre><code>{'species': 'Tub', 'habitat': ['bathroom', 'kitchen']}\n5\n</code></pre> This can be useful if we want to use the popped value later.</p> <p>As we mentioned in the previous sections, <code>len()</code> can also be used to check how many keys in a dictionary: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(len(pet))\n</code></pre> Output<pre><code>3\n</code></pre></p>"},{"location":"02_data_types/#264-accessing-keys-and-values","title":"2.6.4. Accessing Keys and Values","text":"<p>We can access all the keys from a dictionary using <code>keys()</code>: Input<pre><code>pet = {'species': 'Tub', 'age': 5, 'habitat': ['bathroom', 'kitchen']}\nprint(pet.keys())\n</code></pre> Output<pre><code>dict_keys(['species', 'age', 'habitat'])\n</code></pre></p> <p>We can also access all the values from a dictionary using <code>values()</code>: Input<pre><code>print(pet.values())\n</code></pre> Output<pre><code>dict_values(['Tub', 5, ['bathroom', 'kitchen']])\n</code></pre></p> <p>If we want to access the key-value pairs, we can use <code>items()</code>: Input<pre><code>print(pet.items())\n</code></pre> Output<pre><code>dict_items([('species', 'Tub'), ('age', 5), ('habitat', ['bathroom', 'kitchen'])])\n</code></pre> This is convenient if we want to loop through the key-value pairs.</p>"},{"location":"02_data_types/#27-sets","title":"2.7. Sets","text":"<p>Sets are unordered collections of unique elements and are useful when we want to store a collection of items that are not in any particular order and we don't want to store duplicate items.</p>"},{"location":"02_data_types/#271-creating-a-set","title":"2.7.1. Creating a Set","text":"<p>Create an empty set is similar to creating an empty list, you can use <code>set()</code>. Although the brackets <code>{}</code> are also used to create a set, it is actually creating an empty dictionary. To create an empty set, you need to use <code>set()</code>: Input<pre><code>empty_dict = {} # This is to create an empty dictionary\nempty_set = set() # This is to create an empty set\nprint(type(empty_dict))\nprint(empty_set)\nprint(type(empty_set))\n</code></pre> Output<pre><code>&lt;class 'dict'&gt;\nset()\n&lt;class 'set'&gt;\n</code></pre></p> <p>Create a set based on the same strings as the list <code>pet</code>: Input<pre><code>pet = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\nprint(type(pet))\nprint(pet)\n</code></pre> Output<pre><code>&lt;class 'set'&gt;\n{'Tub', 'Cat', 'Barkalot', 'Furrytail'}\n</code></pre></p> <p><code>set</code> Doesn't Care About Order</p> <p>Notice that the order of the elements in the set is different from the order of the elements in the list <code>pet</code>. This is because sets are unordered collections of unique elements. If you run it multiple times, the order will be different as sets don't care about the order of the elements.</p>"},{"location":"02_data_types/#272-set-methods","title":"2.7.2. Set Methods","text":"<p>If we create a set with duplicate elements, the set will only keep one copy of the element: Input<pre><code># Sets throw away the duplicate elements.\npet = {'Tub', 'Furrytail', 'Cat', 'Barkalot', 'Tub'}\nprint(pet)\n</code></pre> Output<pre><code>{'Tub', 'Cat', 'Barkalot', 'Furrytail'}\n</code></pre></p> <p>Sets are optimized for checking whether an element is contained in the set. Input<pre><code>pet = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\nprint('Tub' in pet)\nprint('Tub' not in pet)\n</code></pre> Output<pre><code>True\nFalse\n</code></pre></p> <p>We can check if two sets of pet in common using <code>intersection()</code>: Input<pre><code># What these pet have in common\npet_1 = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\npet_2 = {'Tub', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\nprint(pet_1.intersection(pet_2))\n</code></pre> Output<pre><code>{'Tub', 'Furrytail'}\n</code></pre></p> <p>We can also check if two sets of pet not in common using <code>difference()</code>: Input<pre><code># What these pet don't have in common\npet_1 = {'Tub', 'Furrytail', 'Cat', 'Barkalot'}\npet_2 = {'Tub', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\nprint(pet_1.difference(pet_2))\n</code></pre> Output<pre><code>{'Cat', 'Barkalot'}\n</code></pre></p> <p>Finally, we can also union both of the sets using <code>union()</code>: Input<pre><code># What these pet have in common and what they don't have in common\nprint(pet_1.union(pet_2))\n</code></pre> Output<pre><code>{'Tub', 'Cat', 'Barkalot', 'Furrytail', 'Bumblefluff ', 'Whiskerfloof'}\n</code></pre></p>"},{"location":"03_control_functions/","title":"3. Control and Functions","text":""},{"location":"03_control_functions/#31-conditionals-and-booleans","title":"3.1. Conditionals and Booleans","text":"<p><code>if</code> statements are used to control the flow of the program. It allows us to execute a block of code if a certain condition is met. <code>else</code> statements are used to execute a block of code if the condition is not met. <code>elif</code> is to add more conditions to the <code>if</code> statement, which stands for <code>else if</code>.</p>"},{"location":"03_control_functions/#311-if-and-boolean-values","title":"3.1.1. <code>if</code> and Boolean Values","text":"<p>Input<pre><code>if True:\nprint(\"It's true!\")\n</code></pre> Output<pre><code>It's true!\n</code></pre></p> <p>What if we change the condition to <code>False</code>? Input<pre><code>if False:\nprint(\"It's true!\")\n</code></pre> Output<pre><code># Nothing will be printed\n</code></pre> This is because that the condition is <code>False</code>, so the block of code is not executed.</p> <p>In real practice, we don't hardcode the condition to be <code>True</code> or <code>False</code>, we basically assess the condition to be <code>True</code> or <code>False</code></p> <p>For example, we can use comparison operators to compare two values: Input<pre><code>pet = 'Tub'\nif pet == 'Tub':\nprint(\"It's true!\")\n</code></pre> Output<pre><code>It's true!\n</code></pre></p> <p>Comparison Operators</p> <p>Recall the operator we used in the previous chapter. This time, we use them in the condition, plus the identity operator <code>is</code>.</p> <ul> <li>Equal: <code>==</code></li> <li>Not Equal: <code>!=</code></li> <li>Greater Than: <code>&gt;</code></li> <li>Less Than: <code>&lt;</code></li> <li>Greater or Equal: <code>&gt;=</code></li> <li>Less or Equal: <code>&lt;=</code></li> <li>Identity: <code>is</code></li> </ul>"},{"location":"03_control_functions/#312-if-else-and-elif","title":"3.1.2. <code>if</code>, <code>else</code>  and <code>elif</code>","text":"<p>Let's continue on the previous example. We campare <code>pet</code> and <code>Tub</code> to see if the pet is <code>Tub</code></p> <p>Input<pre><code>pet = 'Tub'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is Tub!\n</code></pre></p> <p>If we change the value of <code>pet</code> to <code>Barkalot</code>, the condition is not met, so the <code>else</code> statement is executed. Input<pre><code>pet = 'Barkalot'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is not Tub!\n</code></pre></p> <p>We can also use <code>elif</code> to add more conditions to the <code>if</code> statement. Here we have two conditions, <code>pet == 'Tub'</code> and <code>pet == 'Barkalot'</code>. If the first condition is not met, we move on to the next condition. If the second condition is not met, we move on to the <code>else</code> statement:</p> <p>Input<pre><code>pet = 'Barkalot'\nif pet == 'Tub':\nprint(\"Pet is Tub!\")\nelif pet == 'Barkalot':\nprint(\"Pet is Barkalot!\")\nelse:\nprint(\"Pet is not Tub!\")\n</code></pre> Output<pre><code>Pet is Barkalot!\n</code></pre></p>"},{"location":"03_control_functions/#313-is-vs","title":"3.1.3. <code>is</code> vs. <code>==</code>","text":"<p>Now, we investigate the difference between <code>is</code> and <code>==</code>:</p> <ul> <li> <p><code>is</code> checks if two variables point to the same object in memory.</p> </li> <li> <p><code>==</code> checks if the values of two variables are equal.</p> </li> </ul> <p>Here, we have two list with the same values. </p> <p>Input<pre><code>pet_1 = ['Tub', 'Barkalot', 'Furrytail']\npet_2 = ['Tub', 'Barkalot', 'Furrytail']\n</code></pre> We use <code>==</code> to compare them, and the result is <code>True</code>.  Input<pre><code>print(pet_1 == pet_2)\n</code></pre> Output<pre><code>True\n</code></pre> This is because that the values of the two lists are the same.</p> <p>If we use <code>is</code> to compare them, the result is <code>False</code>. Input<pre><code>print(pet_1 is pet_2)\n</code></pre> Output<pre><code>False\n</code></pre> The reason is that <code>pet_1</code> and <code>pet_2</code> point to different objects in memory.</p> <p>We can check out the memory address of the two objects using <code>id()</code>: Input<pre><code>print(id(pet_1))\nprint(id(pet_2))\n</code></pre> Output<pre><code>2398480322752\n2398482691520\n</code></pre> You can see that the memory addresses are different.</p> <p>But if we assign <code>pet_2</code> to <code>pet_1</code>, they will point to the same object in memory, and of course have the same values. Input<pre><code>pet_2 = pet_1\nprint(pet_1 == pet_2)\nprint(pet_1 is pet_2)\n</code></pre> Output<pre><code>True\nTrue\n</code></pre> Now, the memory addresses are the same:</p>"},{"location":"03_control_functions/#314-and-or-and-not","title":"3.1.4. <code>and</code>, <code>or</code> and <code>not</code>","text":"<p>We can use <code>and</code> and <code>or</code> to combine conditions. </p> <ul> <li> <p><code>and</code> means both conditions must be met</p> </li> <li> <p><code>or</code> means at least one condition must be met</p> </li> </ul> <p>For example, we want to check if both the account name is <code>Tub</code> and the passcode is correct by using <code>and</code>: Input<pre><code>account_name = 'Tub'\naccount_passcode = True\nif account_name == 'Tub' and account_passcode:\nprint(\"Login successful!\")\nelse:\nprint(\"Login failed!\")\n</code></pre> Output<pre><code>Login successful!\n</code></pre></p> <p>If we want to know if at least one of the account name or account passcode is correct, we use <code>or</code>: Input<pre><code>account_name = 'Tub'\naccount_passcode = True\nif account_name == 'Tub' or account_passcode:\nprint(\"Name or passcode is correct!\")\nelse:\nprint(\"Name and passcode are incorrect!\")\n</code></pre> Output<pre><code>Name or passcode is correct!\n</code></pre></p> <p>If we want to negate a condition, we use <code>not</code>. </p> <ul> <li><code>not</code> means the condition must not be met Input<pre><code>account_passcode = True\nif not account_passcode:\nprint(\"Please enter your passcode!\")\nelse:\nprint(\"Login successful!\")\n</code></pre> Output<pre><code>Login successful!\n</code></pre> Here, we use <code>not</code> to negate the condition <code>account_passcode == True</code> to <code>account_passcode == False</code>.  Therefore, the condition must not be met, and the <code>else</code> statement is not executed. </li> </ul> <p>If we remove <code>not</code>, the condition must be met, which is <code>account_passcode == True</code>, and the <code>if</code> statement is executed.  Input<pre><code>account_passcode = True\nif account_passcode:\nprint(\"Please enter your passcode!\")\nelse:\nprint(\"Login successful!\")\n</code></pre> Output<pre><code>Please enter your passcode!\n</code></pre></p>"},{"location":"03_control_functions/#315-in-and-not-in","title":"3.1.5. <code>in</code> and <code>not in</code>","text":"<p>We can use <code>in</code> to check if a value is in a list. </p> <ul> <li> <p><code>in</code> means the value must be in the list</p> </li> <li> <p><code>not in</code> means the value must not be in the list</p> </li> </ul> <p>Here is the example of <code>in</code>: Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nif 'Tub' in pets:\nprint(\"Tub is in the list!\")\nelse:\nprint(\"Tub is not in the list!\")\n</code></pre> Output<pre><code>Tub is in the list!\n</code></pre></p> <p>If we use <code>not in</code>, the condition is negated, and the <code>else</code> statement is executed: Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nif 'Tub' not in pets:\nprint(\"Tub is not in the list!\")\nelse:\nprint(\"Tub is in the list!\")\n</code></pre> Output<pre><code>Tub is in the list!\n</code></pre></p>"},{"location":"03_control_functions/#316-false-values","title":"3.1.6. False Values","text":"<p>False Values</p> <p>In Python, the following values are considered as <code>False</code>:</p> <ul> <li><code>False</code></li> <li><code>None</code></li> <li><code>0</code> (any zero numeric types)</li> <li>Empty sequence. e.g., <code>''</code>, <code>()</code>, <code>[]</code>.</li> <li>Empty mapping. e.g., <code>{}</code>.</li> </ul> <p><code>False</code> is considered as False: Input<pre><code>account_name = False\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p><code>None</code> is considered as False: Input<pre><code>account_name = None\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Only number <code>0</code> is considered as False: Input<pre><code>account_name = 0\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Empty sequences, e.g. <code>''</code>, <code>()</code>, <code>[]</code>, are considered as False: Input<pre><code>account_name = ''\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p> <p>Empty dictionary is considered as False Input<pre><code>account_name = {}\nif account_name:\nprint(\"Login successful!\")\nelse:\nprint(\"Please enter your account name!\")\n</code></pre> Output<pre><code>Please enter your account name!\n</code></pre></p>"},{"location":"03_control_functions/#32-functions","title":"3.2. Functions","text":"<p>In this section, we will walk you through various examples related to functions in Python, exploring different concepts such as defining and calling functions, arguments, default values, and more.</p>"},{"location":"03_control_functions/#321-functions-basics","title":"3.2.1. Functions Basics","text":"<p>First, let's define a simple function called hello_tub: Input<pre><code>def hello_tub():\npass\nprint(hello_tub)\n</code></pre></p> <p>Output<pre><code>&lt;function hello_world at 0x000001E5F1F9B790&gt;\n</code></pre> This function does nothing, as it contains a pass statement. When you print the function, you will get the memory address of the function object:</p> Input<pre><code>print(hello_tub())\n</code></pre> <p>Output<pre><code>None\n</code></pre> Calling the function with <code>hello_tub()</code> returns None, as the function has no return statement.</p> <p>Now, let's modify the hello_tub function to print a greeting: Input<pre><code>def hello_tub():\nprint('Hello Tub')\nhello_tub()\n</code></pre></p> Output<pre><code>Hello Tub\n</code></pre> <p>Using functions is advantageous when you want to reuse code. For instance, if you want to change the greeting from <code>Tub</code> to <code>Barkalot</code>, you only need to modify the function's implementation, and all the calls to the function will use the updated greeting.</p> <p>For example, if we want to call <code>Hello Tub</code> twice, we can do the following: Input<pre><code>print('Hello Tub')\nprint('Hello Tub')\n</code></pre> Output<pre><code>Hello Tub\nHello Tub\n</code></pre> But this is not convenient, as we have to repeat the same code twice. Instead, we can define a function and call it twice, and even if we want to change both <code>Tub</code>:</p> <p>Input<pre><code>def hello_tub():\nprint('Hello Barkalot')\nhello_tub()\nhello_tub()\n</code></pre> Output<pre><code>Hello Barkalot\nHello Barkalot\n</code></pre></p> <p>Functions can also return values, take parameters, and have default values for parameters. Here are some examples:</p> <p>Input<pre><code>def hello_tub():\nreturn 'Hello Tub'\nprint(hello_tub())\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>We can also call the function with a method, e.g. <code>lower()</code>, to convert the returned value to lowercase:</p> <p>Input<pre><code>print(hello_tub().lower())\n</code></pre> Output<pre><code>hello tub\n</code></pre></p> <p>Functions can also return values, take parameters, and have default values for parameters. Here are some examples:</p> <p>Input<pre><code>def hello_tub(name):\nreturn 'Hello ' + name\nprint(hello_tub('Tub'))\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>Input<pre><code>def hello_tub(name):\nreturn 'Hello {}'.format(name)\nprint(hello_tub('Tub'))\n</code></pre> Output<pre><code>Hello Tub\n</code></pre></p> <p>We set up a default value for the name parameter, so that if we don't pass a value for name, the function will use the default value: Input<pre><code>def hello_tub(greeting, name = 'Tub'):\nreturn '{}, {}'.format(greeting, name)\nprint(hello_tub('Hello'))\n</code></pre> Output<pre><code>Hello, Tub\n</code></pre></p> <p>When we pass a value for name, the default value is ignored: Input<pre><code>print(hello_tub('Hello', 'Barkalot'))\n</code></pre> Output<pre><code>Hello, Barkalot\n</code></pre></p>"},{"location":"03_control_functions/#322-positional-arguments","title":"3.2.2. Positional Arguments","text":"<p>In Python, non-default arguments (those without default values) must be defined before default arguments (those with default values). In the given code, the greeting parameter has a default value, while name does not. This causes a SyntaxError.</p> <p>Input<pre><code>def hello_tub(greeting = 'Hello', name):\nreturn '{}, {}'.format(greeting, name)\n</code></pre> Output<pre><code>SyntaxError: non-default argument follows default argument\n</code></pre></p> <p>To fix this issue, you should move the non-default argument before the default argument:</p> <p>Input<pre><code>def hello_tub(name, greeting='Hello'):\nreturn '{}, {}'.format(greeting, name)\n</code></pre> Now, the function works as expected, and you can call it with or without providing a greeting argument:</p> <p>Input<pre><code>print(hello_tub('Tub'))\nprint(hello_tub('Tub', 'Hi'))\n</code></pre> Output<pre><code>Hello, Tub\nHi, Tub\n</code></pre></p> <p>Below let's go through a real example how to find the number of days in a month</p> <p>Example - Find the number of days in a month</p> <p>Credits: Python Standard Library, and Corey Schafer.</p> <p>Number of days per month. First value placeholder for indexing purposes.</p> <p>month_days<pre><code>month_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n</code></pre> The <code>is_leap()</code> function takes a year as input and returns True if it's a leap year, and False otherwise. Leap years are those divisible by 4, but not divisible by 100, unless they are also divisible by 400.</p> <p>is_leap()<pre><code>def is_leap(year):\n\"\"\"\n    Return True for leap years, False for non-leap years.\n    \"\"\"\nreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n</code></pre> The <code>days_in_month()</code> function takes a year and a month as input and returns the number of days in that month for that year. It checks if the input year is a leap year and adjusts the number of days in February accordingly. If an invalid month is provided, it returns <code>Invalid Month</code>.</p> <p>days_in_month()<pre><code>def days_in_month(year, month):\n\"\"\"\n    Return number of days in that month in that year.\n    \"\"\"\nif not 1 &lt;= month &lt;= 12:\nreturn 'Invalid Month'\nif month == 2 and is_leap(year):\nreturn 29\nreturn month_days[month]\n</code></pre> Finally, the code demonstrates calling the <code>is_leap()</code> and <code>days_in_month()</code> functions with specific inputs:</p> <p>Print<pre><code>print(is_leap(2023))\nprint(days_in_month(2023, 4))\n</code></pre> Output<pre><code>False\n30\n</code></pre></p>"},{"location":"03_control_functions/#323-args-and-kwargs","title":"3.2.3. <code>*args</code> and <code>**kwargs</code>","text":"<p>In the following code, there are several concepts being illustrated: <code>*args</code>, <code>**kwargs</code>, and two custom functions <code>is_leap()</code> and <code>days_in_month()</code>.</p> <p><code>*args</code> and <code>**kwargs</code> are used in function definitions to allow passing a variable number of arguments. <code>*args</code> is used for passing a variable number of non-keyword (positional) arguments, while <code>**kwargs</code> is used for passing a variable number of keyword arguments.</p> <p>Input<pre><code>def pet_info(*args, **kwargs):\nprint(args)\nprint(kwargs)\npet_info('Tub', 'Barkalot', 'Furrytail', pet1 = 'Tub', pet2 = 'Barkalot', pet3 = 'Furrytail')\n</code></pre> Output<pre><code>('Tub', 'Barkalot', 'Furrytail')\n{'pet1': 'Tub', 'pet2': 'Barkalot', 'pet3': 'Furrytail'}\n</code></pre> In the <code>pet_info()</code> function, both <code>*args</code> and <code>**kwargs</code> are used. When you call the function with different types of arguments, you can see how they are grouped and printed:</p> <p>Input<pre><code>def pet_info(*args, **kwargs):\nprint(args)\nprint(kwargs)\nfavorite_food = ['Carrot', 'Brocolli', 'Ice Cream']\ninfo = {'name': 'Tub', 'age': 25}\npet_info(favorite_food, info)\n</code></pre> In the first call to pet_info, we pass a list <code>favorite_food</code> and a dictionary info as arguments without using the <code>*</code> or <code>**</code> unpacking operators. This means the entire list and dictionary are treated as single positional arguments. The output shows that args contains a tuple with two elements: the list <code>favorite_food</code> and the dictionary info. Since we didn't provide any keyword arguments, kwargs is an empty dictionary.</p> Output<pre><code>(['Carrot', 'Brocolli', 'Ice Cream'], {'name': 'Tub', 'age': 25})\n{}\n</code></pre> <p>In the second call to pet_info, we use the <code>*</code> and <code>**</code> unpacking operators to pass the list favorite_food and the dictionary info as individual elements. The <code>*</code> operator unpacks the list elements as positional arguments, and the <code>**</code> operator unpacks the dictionary items as keyword arguments. In this case, the output shows that args contains a tuple with three elements ('<code>Carrot</code>', '<code>Brocolli</code>', '<code>Ice Cream</code>') and kwargs contains a dictionary with the keys and values from the info dictionary.</p> <p>Input<pre><code>pet_info(*favorite_food, **info)\n</code></pre> Output<pre><code>('Carrot', 'Brocolli', 'Ice Cream')\n{'name': 'Tub', 'age': 25}\n</code></pre></p>"},{"location":"03_control_functions/#323-variable-scope-legb-rule","title":"3.2.3. Variable Scope - LEGB rule","text":"<p>In this section, we are discussing variable scope in Python, which determines where a variable can be accessed or modified. Python searches for a variable following the LEBG rule and order: Local, Enclosing, Global, and Built-in.</p> <p>Local A variable defined within a function has local scope. It can only be accessed inside that function.</p> <p>Input<pre><code>def test():\ny = 'local variable y'\nprint(y)\ntest()\n</code></pre> Output<pre><code>local variable y\n</code></pre></p> <p>Global</p> <p>A variable defined outside any function has global scope. It can be accessed both inside and outside of functions.</p> <p>In the following example, we define a variable <code>x</code> outside of the <code>test()</code> function. We can access and modify this variable inside the function. </p> <p>Input<pre><code>x = 'global variable x'\ndef test():\ny = 'local variable y'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>global variable x\nglobal variable x\n</code></pre> Here the results are the same because we are accessing the global variable <code>x</code> inside the function. However, if we try to access the local variable <code>y</code> outside of the function, we get an error.</p> <p>Input<pre><code>print(y)\n</code></pre> Output<pre><code>NameError: name 'y' is not defined\n</code></pre></p> <p>What if we have a variable with the same name inside and outside of a function? In this case, the local variable takes precedence over the global variable. The following example demonstrates this:</p> <p>Input<pre><code>x = 'global variable x'\ndef test():\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nglobal variable x\n</code></pre> This example shows that the python searches for a variable in the local scope first. If it doesn't find it, it searches the global scope. This is the reason that we get the local variable <code>x</code> inside the function first and the global variable <code>x</code> next</p> <p>If it doesn't find it there, it will throw an error. </p> <p>In the next example, we demonstrate how to use the global keyword to change the value of a global variable within a function. </p> <p>Input<pre><code># What if we want to set a new global x\nx = 'global variable x'\ndef test():\nglobal x\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nlocal variable x\n</code></pre></p> <p>In this example, we use the <code>global</code> keyword to change the value of the global variable <code>x</code> inside the function, although this is not recommended in the practice because it can lead to unexpected behavior and make the code difficult to debug and review. </p> <p>You can also do the following:</p> <p>Input<pre><code>def test():\nglobal x\nx = 'local variable x'\nprint(x)\ntest()\nprint(x)\n</code></pre> Output<pre><code>local variable x\nlocal variable x\n</code></pre></p> <p>However, it is not recommended to use global often.</p> <p>Input<pre><code>def test(z):\nprint(z)\ntest('local variable z')\nprint(z)\n</code></pre> Output<pre><code>local variable z\nNameError: name 'z' is not defined\n</code></pre></p> <p>Built-in</p> <p>In this example, we are discussing the built-in scope in Python. Built-in scope refers to the predefined functions and variables available in Python, which are part of the standard library.</p> <p>Python has a set of built-in functions, like min(), max(), print(), etc., which are readily available for use.</p> <p>Input<pre><code># Built-in\nimport builtins\n# print(dir(builtins))\nminimum = min([1,2,3])\nprint(minimum)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>However, you should avoid overwriting built-in functions with your own functions or variables. Doing so can lead to errors or unintended behavior.</p> <p>Input<pre><code># If we overwrite the built-in function min()\ndef min():\npass\nm = min([1,2,3])\nprint(m)\n</code></pre> Output<pre><code>TypeError: min() takes 0 positional arguments but 1 was given\n</code></pre></p> <p>To avoid conflicts with built-in functions, it's a good practice to use different names for your own functions. </p> <p>So the best way to do this is to use a different name instead of the default name <code>min()</code>.</p> <p>Input<pre><code>def find_min():\npass\nminimum = min([1,2,3])\nprint(minimum)\n</code></pre> Output<pre><code>1\n</code></pre></p> <p>Being mindful of built-in functions and avoiding name conflicts will help you write clean, error-free code.</p> <p>Enclosing</p> <p>In this example, we discuss the concept of enclosing scope in Python. Enclosing scope is the scope of variables that are defined in an outer function but not in the global scope. Enclosing scope variables are accessible from the inner function.</p> <p>Let's look at an example:</p> <p>Input<pre><code>x = 'global variable x'\ndef outer():\nx = 'local-outer variable x'\ndef inner():\nx = 'local-inner variable x'\nprint(x) # 1st print\ninner() # 1st call for 1st print\nprint(x) # 2nd print\nouter() # 2nd call for 1st print and 2nd print\nprint(x) # 3rd print\n</code></pre> Output<pre><code>local-inner variable x\nlocal-outer variable x\nglobal variable x\n</code></pre></p> <p>The <code>outer()</code> function has its own local variable <code>x</code>, and the <code>inner()</code> function also has its own local variable x. When we call the functions, the inner function prints its local variable <code>x</code>, the outer function prints its local variable <code>x</code>, and then the global variable x is printed.</p> <p>Now let's use the nonlocal keyword to modify the enclosing variable from the inner function:</p> <p>Input<pre><code>x = 'global variable x'\ndef outer():\nx = 'local-outer variable x'\ndef inner():\nnonlocal x # Make our local-inner variable x to be the enclosing variable x\nx = 'local-inner variable x'\nprint(x)\ninner()\nprint(x)\nouter()\nprint(x)\n</code></pre> Output<pre><code>local-inner variable x\nlocal-inner variable x\nglobal variable x\n</code></pre></p> <p>In this case, we use the nonlocal keyword inside the <code>inner()</code> function to indicate that we want to modify the enclosing variable <code>x</code> (the one defined in the <code>outer()</code> function) instead of creating a new local variable. When the functions are called, both the inner and outer functions print the modified enclosing variable <code>x</code>, and then the global variable <code>x</code> is printed.</p>"},{"location":"04_advanced_formatting/","title":"4. Advanced Formatting","text":"<p>In Chapter 2, we have seen the basic string formatting. In this chapter, we will see some more advanced formatting examples upon on that.  </p>"},{"location":"04_advanced_formatting/#41-formatting-with-placeholders","title":"4.1. Formatting with placeholders","text":"<p>Let's see the following example first:  Input<pre><code>species_1 = {'species': 'Tub', 'age': 5}\nsentence = 'My name is ' + species_1['species'] + ' and I am ' + str(species_1['age']) + ' years old.'\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> We can see there are a lot of blank space we have to manually put in the beginning and the end of each string.  We also have to cast the integer/number, <code>species_1['age']</code>, into strings by using <code>str()</code>. </p> <p>Of course, there is a better way to do this:  Input<pre><code>sentence = 'My name is {} and I am {} years old.'.format(species_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> We can see that we don't have to cast the integer/number into strings anymore.</p> <p>We can also use the index of the placeholder to specify the order of the arguments: Input<pre><code>sentence = 'My name is {0} and I am {1} years old.'.format(species_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre></p> <p>This is another example using the index of the placeholder with repeated arguments: Input<pre><code>tag = 'p'\ntext = 'This is a paragraph'\nsentence = '&lt;{0}&gt;{1}&lt;/{0}&gt;'.format(tag, text)\nprint(sentence)\n</code></pre> Output<pre><code>&lt;p&gt;This is a paragraph&lt;/p&gt;\n</code></pre></p> <p>This is very useful when we have a placeholder that you want to reuse. Let's see another example: Input<pre><code>sentence = 'My name is {0} and I am {1} years old. My friend Barkalot is also {1} years old.'.format(\nspecies_1['species'], species_1['age'])\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old. My friend Barkalot is also 5 years old.\n</code></pre></p> <p>There is another way to do this by using the key in the placeholder instead of the index: Input<pre><code>sentence = 'My name is {0[species]} and I am {1[age]} years old.'.format(species_1, species_1)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> Here, we call the value of the key <code>species</code> in the dictionary <code>species_1</code> by using <code>{0[species]}</code>.</p> <p>But this is redundant because we have to repeat the same argument twice.</p> <p>We can do the following instead: Input<pre><code>sentence = 'My name is {0[species]} and I am {0[age]} years old.'.format(species_1)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre></p> <p>We can also use the index of a list in the placeholder: Input<pre><code>species = ['Tub', 'Furrytail', 'Cat', 'Barkalot']\nsentence = 'I am {0[1]} and my friend is {0[3]}.'.format(species)\nprint(sentence)\n</code></pre> Output<pre><code>I am Furrytail and my friend is Barkalot.\n</code></pre></p> <p>We can also access the attributes of an object in the same way. For example, we define a class called <code>Species</code> that represents a species with a <code>species</code> and an <code>age</code>. The class has an <code>__init__</code> method that initializes the instance variables species and age. We then create an instance of the <code>Species</code> class called <code>species_new</code> with the name 'Jerry' and the age <code>88</code>.</p> <p>You then create an instance of the Species class called species_new with the name 'Jerry' and the age 88. Input<pre><code>class Species:\ndef __init__(self, species, age):\nself.species = species\nself.age = age\nspecies_new = Species('Jerry', 88)\n</code></pre> Now we can access the attributes of the object <code>species_new</code> by using the index of the placeholder: Input<pre><code>sentence = 'My name is {0.species} and I am {0.age} years old.'.format(species_new)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Jerry and I am 88 years old.\n</code></pre> The string contains placeholders <code>{0.species}</code> and <code>{0.age}</code> which will be replaced by the species and age attributes of the <code>species_new</code> object. The <code>0</code> in the placeholders refers to the first argument passed to the <code>.format()</code> method, which is <code>species_new</code>.</p> <p>This time, we are using keyword arguments to pass the values that will replace the placeholders in the string. The string contains placeholders <code>{species}</code> and <code>{age}</code>, which will be replaced by the values provided as keyword arguments in the <code>.format()</code> method.</p> <p>Input<pre><code>sentence = 'My name is {species} and I am {age} years old.'.format(species='Jerry', age=88)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Jerry and I am 88 years old.\n</code></pre></p>"},{"location":"04_advanced_formatting/#42-in-format","title":"4.2. <code>**</code> in `.format()","text":"<p>In the format() method, the ** operator can be used to unpack a dictionary that contains the keyword arguments for the placeholders in the string. This can be a convenient way to format a string using a dictionary that has keys matching the placeholders in the string.</p> <p>Here's an example: Input<pre><code>pet = {'species': 'Tub', 'age': 5}\nsentence = 'My name is {species} and I am {age} years old.'.format(**pet)\nprint(sentence)\n</code></pre> Output<pre><code>My name is Tub and I am 5 years old.\n</code></pre> In this example, we have a dictionary <code>pet</code> containing the keys <code>species</code> and <code>age</code>. We then use the <code>**</code> operator to unpack the dictionary when calling the <code>.format()</code> method on the string. The values from the dictionary are used to replace the placeholders in the string, resulting in the sentence <code>\"My name is Tub and I am 5 years old.\"</code></p> <p>This method is useful when we print out the dictionaries, which is more readable.</p> <p>why use <code>**species</code> instead of <code>species</code>?</p> <p>When you use <code>**</code> before a dictionary in a function call, like in the <code>.format()</code> method, it is known as dictionary unpacking. It allows you to pass the key-value pairs in the dictionary as named (keyword) arguments to the function.</p> <p>When a dictionary is passed as a keyword argument in this way, the keys in the dictionary are treated as the parameter names and the corresponding values are passed as the parameter values.</p> <p>So, in this case, the keys in the <code>pet</code> dictionary (<code>'species'</code> and <code>'age'</code>) are treated as parameter names in the sentence string, and their corresponding values (<code>'Tub'</code> and <code>5</code>) are passed as parameter values.</p> <p>If you were to pass the pet dictionary without the double asterisks, like so:</p> <p>Input<pre><code>sentence = 'My name is {species} and I am {age} years old.'.format(species)\nprint(sentence)\n</code></pre> Output<pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'species'\n</code></pre></p> <p>The <code>.format()</code> method would be looking for a single argument that is a dictionary, rather than separate keyword arguments, and would raise a TypeError.</p>"},{"location":"04_advanced_formatting/#43-formatting-numbers","title":"4.3. Formatting Numbers","text":"<p>In this block, we are using the <code>.format()</code> method to insert values into a string. The <code>{}</code> serves as a placeholder for the value that will be inserted. The output will be a series of strings with the respective values from the loop.</p> <p>Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 1\nThe value is 2\nThe value is 3\nThe value is 4\nThe value is 5\n</code></pre></p> <p>Padding with zeros (width 2): In this block, we're using the :02 format specifier within the placeholder to pad the value with zeros, ensuring a minimum width of 2 characters. This is useful for maintaining consistent formatting when dealing with numbers of varying lengths. Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {:02}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 01\nThe value is 02\nThe value is 03\nThe value is 04\nThe value is 05\n</code></pre></p> <p>Padding with zeros (width 3): Similarly, we can use the :03 format specifier to pad the value with zeros, ensuring a minimum width of 3 characters. This results in a more extensive padding for the smaller numbers, keeping the output format consistent. Input<pre><code>for i in range(1, 6):\nsentence = 'The value is {:03}'.format(i)\nprint(sentence)\n</code></pre> Output<pre><code>Output:\nThe value is 001\nThe value is 002\nThe value is 003\nThe value is 004\nThe value is 005\n</code></pre></p> <p>By using <code>:.2f</code> within the placeholder, we can format a floating-point number to display two decimal places.</p> <p>Input<pre><code># We can also use the `:.2f` with two decimal places\ne = 2.71828\nsentence = 'e is equal to {:.2f}'.format(e)\nprint(sentence)\n</code></pre> Output<pre><code>e is equal to 2.72\n</code></pre></p> <p>By using <code>:,</code> within the placeholder, we can format a number with a thousands separator, <code>,</code>.  Input<pre><code>sentence = '1 KM is equal to {:,.2f} meters'.format(1000)\nprint(sentence)\n</code></pre> Output<pre><code>1 KM is equal to 1,000.00 meters\n</code></pre></p>"},{"location":"04_advanced_formatting/#44-formatting-date-and-time-with-datetime","title":"4.4. Formatting Date and Time with <code>datetime</code>","text":"<p>When formatting date and time, we can refer to the strftime and strptime behavior for the format codes.</p> <p>In the following code, we are using Python's <code>datetime</code> module to create a <code>datetime</code> object representing a specific date and time. We create a <code>datetime</code> object for <code>April 1, 2023, 10:10:30 AM</code>, and print it. Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\nprint(today_date)\n</code></pre> Output<pre><code>2023-04-01 10:10:30\n</code></pre></p> <p>We can use the <code>strftime</code> method to format the date in a more human-readable format. The <code>strftime</code> method allows you to create custom date and time formats by using format codes. We can use the <code>strftime</code> method to format the date. </p> <p>But we have to import the <code>datetime</code> module first. </p> <p>Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\ntoday_date = '{:%B %d, %Y}'.format(today_date)\nprint(today_date)\n</code></pre> Output<pre><code>April 01, 2023\n</code></pre> Here, we use the format codes %B, %d, and %Y to display the full month name, the day of the month with a leading zero, and the year with the century, respectively. The resulting formatted date is passed to the format function and printed.</p> <p>We can also use the <code>strptime</code> method to parse the string into a date: Input<pre><code>import datetime\ndate_str = 'April 01, 2023'\ntoday_date = datetime.datetime.strptime(date_str, '%B %d, %Y')\nprint(today_date)\n</code></pre> Output<pre><code>2023-04-01 00:00:00\n</code></pre> n this example, we have the date string <code>'April 01, 2023'. The format codes used to parse this string are</code>%B<code>,</code>%d<code>, and</code>%Y`, which represent the full month name, the day of the month with a leading zero, and the year with the century, respectively. The strptime method reads the date string and creates a datetime object with the provided date information. Input<pre><code>import datetime\ntoday_date = datetime.datetime(2023, 4, 1, 10, 10, 30)\nsentence = 'Today is {0:%B %d, %Y} on {0:%A}, and {0:%Y} has passed {0:%j} days'.format(today_date)\nprint(sentence)\n</code></pre> Output<pre><code>Today is April 01, 2023 on Thursday, and 2023 has passed 091 days\n</code></pre></p> <p>We can also use the <code>timetuple</code> method to remove the <code>0</code> in the beginning of <code>091</code>: Input<pre><code>sentence = 'Today is {0:%B %d, %Y} on {0:%A}, and {0:%Y} has passed {1:d} days'.format(today_date, today_date.timetuple().tm_yday)\nprint(sentence)\n</code></pre> Output<pre><code>Today is April 01, 2023 on Thursday, and 2023 has passed 91 days\n</code></pre></p>"},{"location":"05_loops_comprehensions/","title":"5. Loops and Comprehensions","text":""},{"location":"05_loops_comprehensions/#51-loops","title":"5.1. Loops","text":"<p>This chapter provides an overview of loops and iterations in Python, specifically focusing on the <code>for</code>, <code>while</code>, and <code>else</code> statements.</p>"},{"location":"05_loops_comprehensions/#511-for-loops","title":"5.1.1. For Loops","text":"<ul> <li>Basic Usage: The for loop iterates over a list of pets and prints each pet's name. This is the simplest usage of a for loop.</li> <li><code>break</code> Statement: The for loop is used in combination with a conditional statement and break, which terminates the loop once a specific condition is met. In this case, the loop is terminated when the pet name is <code>Barkalot</code>.</li> <li><code>continue</code> Statement: The continue statement is used to skip the rest of the current loop iteration and immediately start the next one. Here, when the pet name is <code>Barkalot</code>, the loop prints a special message and then immediately starts the next iteration, skipping the usual print statement.</li> <li>Nested for Loops: This demonstrates the concept of nested loops, where a for loop is contained within another for loop. The outer loop iterates over the pet names, and the inner loop iterates over the letters <code>a</code> and <code>b</code> or the numbers <code>0</code> and <code>1</code>.</li> <li><code>range()</code> Function: The <code>range()</code> function generates a sequence of numbers over which the for loop iterates. The function can be called with different numbers of arguments to change the start, end, and step size of the sequence.</li> </ul> <p>This chapter provides an excellent foundation for understanding loops in Python. The various concepts and techniques it introduces are fundamental to many kinds of programming tasks.</p>"},{"location":"05_loops_comprehensions/#basic-usage","title":"Basic Usage","text":"<p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nprint(pet)\n</code></pre> Output<pre><code>Tub\nBarkalot\nFurrytail\n</code></pre> This code creates a list of pet names, then uses a <code>for</code> loop to iterate over each item in the list. Each time through the loop, it prints the current pet name.</p>"},{"location":"05_loops_comprehensions/#break-statement","title":"<code>break</code> Statement","text":"<p>Input<pre><code>pets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nif pet == 'Barkalot':\nprint('We got Barkalot!')\nbreak\nprint(pet)\n</code></pre> Output<pre><code>Tub\nWe got Barkalot!\n</code></pre> This code is similar to the previous example, but it includes an <code>if</code> statement that checks whether the current pet name is <code>Barkalot</code>. If it is, the code prints a special message and then uses the <code>break</code> statement to immediately exit the loop.</p>"},{"location":"05_loops_comprehensions/#continue-statement","title":"<code>continue</code> Statement","text":"<p>Input<pre><code># `continue` statement skip the current iteration and continue with the next.\n# Here we skip the `Barkalot` pet and print `We got Barkalot!` instead.\npets = ['Tub', 'Barkalot', 'Furrytail']\nfor pet in pets:\nif pet == 'Barkalot':\nprint('We got Barkalot!')\ncontinue\nprint(pet)\n</code></pre> Output<pre><code>Tub\nWe got Barkalot!\nFurrytail\n</code></pre></p> <p>Again, this code is similar to the previous examples. The difference is that when the current pet name is <code>Barkalot</code>, it uses the <code>continue</code> statement to immediately start the next iteration of the loop, skipping the <code>print(pet)</code> statement for <code>Barkalot</code>.</p>"},{"location":"05_loops_comprehensions/#nested-for-loops","title":"Nested for Loops","text":"<p>Input<pre><code>for pet in pets:\nfor letter in 'ab':\nprint(letter, pet)\n</code></pre> Output<pre><code>a Tub\nb Tub\na Barkalot\nb Barkalot\na Furrytail\nb Furrytail\n</code></pre> Here, the outer <code>for</code> loop iterates over the list of pet names, and the inner <code>for</code> loop iterates over the string 'ab'. For each combination of pet name and letter, it prints the letter and the pet name.</p>"},{"location":"05_loops_comprehensions/#range-function","title":"<code>range()</code> Function","text":"<p>Input<pre><code>for pet in pets:\nfor num in range(2):\nprint(num, pet)\n</code></pre> Output<pre><code>0 Tub\n1 Tub\n0 Barkalot\n1 Barkalot\n0 Furrytail\n1 Furrytail\n</code></pre></p> <p>This code is the same as the previous example, but the inner loop iterates over the numbers produced by <code>range(2)</code>, which are 0 and 1.</p>"},{"location":"05_loops_comprehensions/#range-function-with-start-and-end","title":"<code>range()</code> Function with Start and End","text":"<p>Input<pre><code>for num in range(0, 5):\nprint(num)\n</code></pre> Output<pre><code>0\n1\n2\n3\n4\n</code></pre></p> <p>This code uses the <code>range()</code> function to generate a sequence of numbers from 0 to 4. The <code>for</code> loop iterates over these numbers, printing each one.</p>"},{"location":"05_loops_comprehensions/#range-function-with-start-end-and-step","title":"<code>range()</code> Function with Start, End, and Step","text":"<p>Input<pre><code>for num in range(0, 5, 2):\nprint(num)\n</code></pre> Output<pre><code>0\n2\n4\n</code></pre></p> <p>This code is similar to the previous example, but it adds a step size of 2 to the <code>range()</code> function. This means it only generates every second number in the range from 0 to 4, so the <code>for</code> loop prints the numbers 0, 2, and 4.</p>"},{"location":"05_loops_comprehensions/#512-while-loops","title":"5.1.2. While Loops","text":""},{"location":"05_loops_comprehensions/#513-else-loops","title":"5.1.3. Else Loops","text":""},{"location":"05_loops_comprehensions/#52-list-comprehensions","title":"5.2. List Comprehensions","text":""},{"location":"05_loops_comprehensions/#53-zip-introduction-and-examples","title":"5.3. zip introduction and examples","text":""},{"location":"05_loops_comprehensions/#54-enumerate-introduction-and-examples","title":"5.4. enumerate introduction and examples","text":""},{"location":"05_loops_comprehensions/#55-recursive-functions","title":"5.5. Recursive Functions","text":""},{"location":"07_errors/","title":"Comming Soon","text":""},{"location":"08_oop/","title":"Comming Soon","text":""}]}